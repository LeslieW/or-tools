<!-- Good morning, Mr. Phelps. -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>or-tools/src/base/: operations_research Namespace Reference - Doxy</title>
    <link rel="shortcut icon" href="../../../favicon.ico">
    <!-- Both stylesheets are supplied by Doxygen, with maybe minor tweaks from Google. -->
    <link href="../../../doxygen.css" rel="stylesheet" type="text/css">
    <link href="../../../tabs.css" rel="stylesheet" type="text/css">
  </head>

  <body topmargin=0 leftmargin=20 bottommargin=0 rightmargin=20 marginwidth=20 marginheight=0>

  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <!-- Top horizontal line with the color of the day. -->
    <tr valign=top>
      <td colspan=3 bgcolor=#992252 height=3></td>
    </tr>

    <!-- Header row with the links at the right. -->
    <tr valign=top>
      <td colspan=3 align=right>
        <font size=-1>
          Generated on: <font color=#992252><b>Fri Aug 10 02:28:15 CEST 2012</b></font>
            for Revision:2056
        </font>
      </td>
    </tr>

    <!-- Header row with the logo and the search form. -->
    <tr valign=top>
      <!-- Logo. -->
      <td align=left width=150>
        <table width=150 height=54 cellpadding=0 cellspacing=0 border=0>
          <tr valign=top>
            <!-- First part of the secret behind Doxy logo always having the word "Doxy" with the color of the day. -->
            <td>
              <a class="doxy_logo" href="../../../index.html"><img src="../../../doxy_logo.png" alt="OR-Tools" border=0></a>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <!-- Tiny vertical space below the form. -->
    <tr valign=top>
      <td colspan=3 height=3></td>
    </tr>
  </table>

  <!-- Header navigation row. -->
  <div class="memproto">
    <table width=100% cellpadding=0 cellspacing=0 border=0>
      <tr>
        <td align=left style="padding-left: 20px"><font size=+1><b><tt><font color=#333333>//
            <a href="../../../index.html"><font color=#992252>doxy</font></a>/</font>
            <a href="../../../or-tools/index.html">or-tools</a>/
            <a href="../../../or-tools/src/index.html">src</a>/
            <a href="../../../or-tools/src/base/index.html">base</a>/
            </tt></b></font>
        </td>
      </tr>
    </table>
  </div>
  <br />
    <!-- No subdirs found. -->
  <!-- End of header. -->
<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">operations_research Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1AdjustablePriorityQueue.html">AdjustablePriorityQueue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Bitmap.html">Bitmap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1CallbackUtils__.html">CallbackUtils_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ConstIter.html">ConstIter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MutableIter.html">MutableIter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: this class is not compatible with sets (operator* returns a non-const reference).  <a href="classoperations__research_1_1MutableIter.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ConstReverseIter.html">ConstReverseIter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MutableReverseIter.html">MutableReverseIter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Eraser.html">Eraser</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs an iterator-friendly erasure: the element pointed at gets removed from the container and the iterator remains valid and points to the next element.  <a href="classoperations__research_1_1Eraser.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Eraser_3_01std_1_1vector_3_01T_01_4_01_4.html">Eraser&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of the <a class="el" href="classoperations__research_1_1Eraser.html" title="This class performs an iterator-friendly erasure: the element pointed at gets removed from the contai...">Eraser</a> works for vectors.  <a href="classoperations__research_1_1Eraser_3_01std_1_1vector_3_01T_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Eraser_3_01std_1_1deque_3_01T_01_4_01_4.html">Eraser&lt; std::deque&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of the <a class="el" href="classoperations__research_1_1Eraser.html" title="This class performs an iterator-friendly erasure: the element pointed at gets removed from the contai...">Eraser</a> works for deques.  <a href="classoperations__research_1_1Eraser_3_01std_1_1deque_3_01T_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1File.html">File</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1FileLineReader.html">FileLineReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classoperations__research_1_1FileLineReader.html" title="The FileLineReader class will read a text file specified by &#39;filename&#39; line by line.">FileLineReader</a> class will read a text file specified by 'filename' line by line.  <a href="classoperations__research_1_1FileLineReader.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1DateLogger.html">DateLogger</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MathUtil.html">MathUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Mutex.html">Mutex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MutexLock.html">MutexLock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CondVar.html">CondVar</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ACMRandom.html">ACMRandom</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ACM minimal standard random number generator. (re-entrant.)  <a href="classoperations__research_1_1ACMRandom.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RecordWriter.html">RecordWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class appends a protocol buffer to a file in a binary format.  <a href="classoperations__research_1_1RecordWriter.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1RecordReader.html">RecordReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class reads a protocol buffer from a file.  <a href="classoperations__research_1_1RecordReader.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A scoped_ptr&lt;T&gt; is like a T*, except that the destructor of scoped_ptr&lt;T&gt; automatically deletes the pointer it holds (if any).  <a href="classoperations__research_1_1scoped__ptr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1scoped__array.html">scoped_array</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">scoped_array&lt;C&gt; is like scoped_ptr&lt;C&gt;, except that the caller must allocate with new [] and the destructor deletes objects with delete [].  <a href="classoperations__research_1_1scoped__array.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ScopedPtrMallocFree.html">ScopedPtrMallocFree</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class wraps the c library function free() in a class that can be passed as a template argument to <a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html" title="scoped_ptr_malloc&lt;&gt; is similar to scoped_ptr&lt;&gt;, but it accepts a second template argument, the functor used to free the object.">scoped_ptr_malloc</a> below.  <a href="classoperations__research_1_1ScopedPtrMallocFree.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html">scoped_ptr_malloc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">scoped_ptr_malloc&lt;&gt; is similar to scoped_ptr&lt;&gt;, but it accepts a second template argument, the functor used to free the object.  <a href="classoperations__research_1_1scoped__ptr__malloc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1sparsetable.html">sparsetable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implement a simple block based sparse vector.  <a href="classoperations__research_1_1sparsetable.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Barrier.html">Barrier</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1WallTimer.html">WallTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CycleTimer.html">CycleTimer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class of timer is very precise and potentially more expensive than the <a class="el" href="classoperations__research_1_1WallTimer.html">WallTimer</a> class.  <a href="classoperations__research_1_1CycleTimer.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae3eb78859f8162620f6fffe8cac690af">mix</a> (<a class="el" href="integral__types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;a, <a class="el" href="integral__types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;b, <a class="el" href="integral__types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5cdda52220787f2b0cf8273197012f26">mix</a> (<a class="el" href="integral__types_8h.html#a29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;a, <a class="el" href="integral__types_8h.html#a29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;b, <a class="el" href="integral__types_8h.html#a29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa20b89a75a7ba6a894d4771eae8cc192">StrCat</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p1, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">StrCat.  <a href="#aa20b89a75a7ba6a894d4771eae8cc192"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a61ddd7dde406cb842e1f60cbc82364ef">StrCat</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p1, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p2, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a0599ef161abcafe4421df90ff0848fdf">StrCat</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p1, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p2, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p3, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad5b5fc9be061d23eed98bd2b04c95203">StrCat</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p1, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p2, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p3, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p4, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa4b2e584cc91e80c7ab8a264624f015a">StrCat</a> (<a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> a1, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a164ab8a796555d2eb3d18ff5c2725ec9">StrCat</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;p1, <a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> a2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <br class="typebreak"/>
Collection::value_type::second_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa4c61ca91d4d67f0dcb250fd0471e159">FindWithDefault</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key, const typename Collection::value_type::second_type &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a lookup in a map or hash_map.  <a href="#aa4c61ca91d4d67f0dcb250fd0471e159"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <br class="typebreak"/>
Collection::value_type::second_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a268c0156a214b93179cc9cc3dbde36b3">FindOrNull</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a lookup in a map or hash_map.  <a href="#a268c0156a214b93179cc9cc3dbde36b3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Collection::value_type::second_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a90be3316458c80e031f84cc65c5fdb45">FindOrNull</a> (Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a lookup in a map or hash_map.  <a href="#a90be3316458c80e031f84cc65c5fdb45"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <br class="typebreak"/>
Collection::value_type::second_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#af39d408f617b103493963ea1603222ac">FindPtrOrNull</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a lookup in a map or hash_map whose values are pointers.  <a href="#af39d408f617b103493963ea1603222ac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection , class Key , class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#adc393a0cc02feb79f7860333d7a009e7">InsertOrUpdate</a> (Collection *const collection, const Key &amp;key, const Value &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the value associated with a particular key in a map or hash_map.  <a href="#adc393a0cc02feb79f7860333d7a009e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection , class Key , class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a42128d077e0c967c2cb5ada122b9c91c">InsertIfNotPresent</a> (Collection *const collection, const Key &amp;key, const Value &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new key and value into a map or hash_map.  <a href="#a42128d077e0c967c2cb5ada122b9c91c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a16996799c1008f29cd33da7d9366eb72">InsertOrDie</a> (Collection *const collection, const typename Collection::value_type &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new pair&lt;key,value&gt; into a map or hash_map.  <a href="#a16996799c1008f29cd33da7d9366eb72"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a478de9d531f4fe53368ce2e29c7c5cf3">InsertOrDie</a> (Collection *const collection, const typename Collection::value_type::first_type &amp;key, const typename Collection::value_type::second_type &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new key/value into a map or hash_map.  <a href="#a478de9d531f4fe53368ce2e29c7c5cf3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection , class Key , class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ac97f0609a50882b3039174657cfba21e">FindCopy</a> (const Collection &amp;collection, const Key &amp;key, Value *const value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a lookup in map or hash_map.  <a href="#ac97f0609a50882b3039174657cfba21e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection , class Key &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a8089a62e9146eddbeda7c738d64b11e7">ContainsKey</a> (const Collection &amp;collection, const Key &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test to see if a set, map, hash_set or hash_map contains a particular key.  <a href="#a8089a62e9146eddbeda7c738d64b11e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Collection &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <br class="typebreak"/>
Collection::value_type::second_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a0d111cf48eb7acbc8821ee84e04ac5d1">FindOrDie</a> (const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a065344c7f102397737a0dcaaf47da6e9">make_scoped_ptr</a> (C *param)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad02f6e959876060c48ed92a457425943">swap</a> (<a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt; &amp;p1, <a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt; &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free functions.  <a href="#ad02f6e959876060c48ed92a457425943"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a59b54a8f597419873fb3f1b876965dbf">operator==</a> (C *p1, const <a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt; &amp;p2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad9445658a5550f610625680acd2fcec6">operator!=</a> (C *p1, const <a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt; &amp;p2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab7cc8b9fe79bcfca8715d0fca0e29614">swap</a> (<a class="el" href="classoperations__research_1_1scoped__array.html">scoped_array</a>&lt; C &gt; &amp;p1, <a class="el" href="classoperations__research_1_1scoped__array.html">scoped_array</a>&lt; C &gt; &amp;p2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free functions.  <a href="#ab7cc8b9fe79bcfca8715d0fca0e29614"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#af3c8edb4fcf89de5549ae96a56e266c2">operator==</a> (C *p1, const <a class="el" href="classoperations__research_1_1scoped__array.html">scoped_array</a>&lt; C &gt; &amp;p2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa9657706be552d9e051e8cc6cd68537c">operator!=</a> (C *p1, const <a class="el" href="classoperations__research_1_1scoped__array.html">scoped_array</a>&lt; C &gt; &amp;p2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C , class FP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a47a5ddd3ca135251e66b6dcb5953e33a">swap</a> (<a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html">scoped_ptr_malloc</a>&lt; C, FP &gt; &amp;a, <a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html">scoped_ptr_malloc</a>&lt; C, FP &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C , class FP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aeb180cb495a29f70abe18b9f504b56ed">operator==</a> (C *p, const <a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html">scoped_ptr_malloc</a>&lt; C, FP &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C , class FP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a11fee38a4ffa51cb60cf7dd07d4ded50">operator!=</a> (C *p, const <a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html">scoped_ptr_malloc</a>&lt; C, FP &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ITR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a0008d35d0b2da9a367c5e59645ce989b">SplitStringToIteratorUsing</a> (const std::string &amp;full, const char *delim, ITR &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceoperations__research.html#a9ebe475d14950a152d76183cbc9d6b84" title="SplitStringUsing() Split a string using a character delimiter.">SplitStringUsing()</a> Split a string using a character delimiter.  <a href="#a0008d35d0b2da9a367c5e59645ce989b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a9ebe475d14950a152d76183cbc9d6b84">SplitStringUsing</a> (const std::string &amp;full, const char *delim, std::vector&lt; std::string &gt; *res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceoperations__research.html#a9ebe475d14950a152d76183cbc9d6b84" title="SplitStringUsing() Split a string using a character delimiter.">SplitStringUsing()</a> Split a string using a character delimiter.  <a href="#a9ebe475d14950a152d76183cbc9d6b84"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#afa90b22933d5e03746df76247ec43a9e">STLDeleteContainerPointers</a> (ForwardIterator begin, ForwardIterator end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceoperations__research.html#afa90b22933d5e03746df76247ec43a9e" title="STLDeleteContainerPointers() For a range within a container of pointers, calls delete (non-array vers...">STLDeleteContainerPointers()</a> For a range within a container of pointers, calls delete (non-array version) on these pointers.  <a href="#afa90b22933d5e03746df76247ec43a9e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad00841377d86b0e0e99128ce0b8575d3">STLDeleteContainerPairSecondPointers</a> (ForwardIterator begin, ForwardIterator end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceoperations__research.html#ad00841377d86b0e0e99128ce0b8575d3" title="STLDeleteContainerPairSecondPointers() For a range within a container of pairs, calls delete (non-arr...">STLDeleteContainerPairSecondPointers()</a> For a range within a container of pairs, calls delete (non-array version) on the SECOND item in the pairs.  <a href="#ad00841377d86b0e0e99128ce0b8575d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aaea180392c576a0712d14ae2e210d80d">STLStringResizeUninitialized</a> (std::string *s, size_t new_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad0becae3367393311c214235572bc3b5">string_as_array</a> (std::string *str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable char* pointing to a string's internal buffer, which may not be null-terminated.  <a href="#ad0becae3367393311c214235572bc3b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a7f9ba4929d05cd9e1ccacefceac78692">STLDeleteElements</a> (T *container)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceoperations__research.html#a7f9ba4929d05cd9e1ccacefceac78692" title="STLDeleteElements() deletes all the elements in an STL container and clears the container.">STLDeleteElements()</a> deletes all the elements in an STL container and clears the container.  <a href="#a7f9ba4929d05cd9e1ccacefceac78692"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a18abaa8dded040fd7781e7c03f537443">STLDeleteValues</a> (T *v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an STL container consisting of (key, value) pairs, STLDeleteValues deletes all the "value" components and clears the container.  <a href="#a18abaa8dded040fd7781e7c03f537443"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a387611e37af188c1863d74ff2c8a986c">StringAppendV</a> (std::string *const dst, const char *const format, va_list ap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a912395124d379d117a6d9c71d2ffbad7">StringPrintf</a> (const char *const format,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a253b1c2056075b651fa4b2dd751c8c5e">SStringPrintf</a> (std::string *const dst, const char *const format,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a476dd09521b9566e36de70e849dac4ec">StringAppendF</a> (std::string *const dst, const char *const format,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="integral__types_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ac31ca97c330da20f6082581dc81f418e">strto32</a> (const char *nptr, char **endptr, int base)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversions to a 32-bit integer can pass the call to strto[u]l on 32-bit platforms, but need a little extra work on 64-bit platforms.  <a href="#ac31ca97c330da20f6082581dc81f418e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="integral__types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#af0e0204225583d7b1bffcc304b268351">strtou32</a> (const char *nptr, char **endptr, int base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a39284ed8b31adbf1e6a6fa1cebb43947">strto64</a> (const char *nptr, char **endptr, int base)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For now, long long is 64-bit on all the platforms we care about, so these functions can simply pass the call to strto[u]ll.  <a href="#a39284ed8b31adbf1e6a6fa1cebb43947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="integral__types_8h.html#a29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae7f177b4770b82039484d843a83b41e0">strtou64</a> (const char *nptr, char **endptr, int base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="integral__types_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab2a0eaffc9885d8862b0fb3dbc8b60d0">atoi32</a> (const char *nptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Although it returns an int, atoi() is implemented in terms of strtol, and so has differing overflow and underflow behavior.  <a href="#ab2a0eaffc9885d8862b0fb3dbc8b60d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a37f583a495facdccabd33338c3c1212b">atoi64</a> (const char *nptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="integral__types_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5fc9893cea6296a2a523be569cfb86cb">atoi32</a> (const std::string &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience versions of the above that take a string argument.  <a href="#a5fc9893cea6296a2a523be569cfb86cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a35a2fdb75416ff9ae980afa3711a4e92">atoi64</a> (const std::string &amp;s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa6647370e5e668a4a79c09d0e3269639">HasSuffixString</a> (const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;str, const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> &amp;suffix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceoperations__research.html#aa6647370e5e668a4a79c09d0e3269639" title="HasSuffixString() Return true if str ends in suffix.">HasSuffixString()</a> Return true if str ends in suffix.  <a href="#aa6647370e5e668a4a79c09d0e3269639"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class TT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa7818e79e87d3c93e8607edad3c5b643">ThreadSafeIncrement</a> (T *value, <a class="el" href="classoperations__research_1_1Mutex.html">Mutex</a> *sm, TT inc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#af7311bc7b29234833be481c3b9a06448">GetProcessMemoryUsage</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">GetProcessMemoryUsage.  <a href="#af7311bc7b29234833be481c3b9a06448"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a08b84c3f7aa7f7488210416a1a6530f9">RunWorker</a> (void *data)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. </p>
<p>namespace tthread</p>
<p>You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This file defines some IO interfaces to compatible with Google IO specifications.</p>
<p>You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Hash maps and hash sets are compiler dependant.</p>
<p>You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. NOLINT</p>
<p>You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This is an implementation designed to match the anticipated future TR2 implementation of the <a class="el" href="classoperations__research_1_1scoped__ptr.html" title="A scoped_ptr&lt;T&gt; is like a T*, except that the destructor of scoped_ptr&lt;T&gt; automatically deletes the p...">scoped_ptr</a> class, and its closely-related brethren, <a class="el" href="classoperations__research_1_1scoped__array.html" title="scoped_array&lt;C&gt; is like scoped_ptr&lt;C&gt;, except that the caller must allocate with new [] and the destr...">scoped_array</a>, <a class="el" href="classoperations__research_1_1scoped__ptr__malloc.html" title="scoped_ptr_malloc&lt;&gt; is similar to scoped_ptr&lt;&gt;, but it accepts a second template argument, the functor used to free the object.">scoped_ptr_malloc</a>, and make_scoped_ptr.</p>
<p>You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. &lt; _MSC_VER</p>
<p>You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. A string-like object that points to a sized piece of memory.</p>
<p>Functions or methods may use const <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a>&amp; parameters to accept either a "const char*" or a "string" value that will be implicitly converted to a <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a>. The implicit conversion means that it is often appropriate to include this .h file in other files rather than forward-declaring <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> as would be appropriate for most other Google classes.</p>
<p>Systematic usage of <a class="el" href="classoperations__research_1_1StringPiece.html">StringPiece</a> is encouraged as it will reduce unnecessary conversions from "const char*" to "string" and back again.</p>
<p>You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. For strtol* functions.</p>
<p>You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Mac OS X WINDOWS </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ab2a0eaffc9885d8862b0fb3dbc8b60d0"></a><!-- doxytag: member="operations_research::atoi32" ref="ab2a0eaffc9885d8862b0fb3dbc8b60d0" args="(const char *nptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integral__types_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> <a class="el" href="namespaceoperations__research.html#ab2a0eaffc9885d8862b0fb3dbc8b60d0">operations_research::atoi32</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Although it returns an int, atoi() is implemented in terms of strtol, and so has differing overflow and underflow behavior. </p>
<p>atol is the same. </p>

<p>Definition at line <a class="el" href="strtoint_8h_source.html#l00052">52</a> of file <a class="el" href="strtoint_8h_source.html">strtoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5fc9893cea6296a2a523be569cfb86cb"></a><!-- doxytag: member="operations_research::atoi32" ref="a5fc9893cea6296a2a523be569cfb86cb" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integral__types_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> <a class="el" href="namespaceoperations__research.html#ab2a0eaffc9885d8862b0fb3dbc8b60d0">operations_research::atoi32</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience versions of the above that take a string argument. </p>

<p>Definition at line <a class="el" href="strtoint_8h_source.html#l00061">61</a> of file <a class="el" href="strtoint_8h_source.html">strtoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="a37f583a495facdccabd33338c3c1212b"></a><!-- doxytag: member="operations_research::atoi64" ref="a37f583a495facdccabd33338c3c1212b" args="(const char *nptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> <a class="el" href="namespaceoperations__research.html#a37f583a495facdccabd33338c3c1212b">operations_research::atoi64</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="strtoint_8h_source.html#l00056">56</a> of file <a class="el" href="strtoint_8h_source.html">strtoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="a35a2fdb75416ff9ae980afa3711a4e92"></a><!-- doxytag: member="operations_research::atoi64" ref="a35a2fdb75416ff9ae980afa3711a4e92" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> <a class="el" href="namespaceoperations__research.html#a37f583a495facdccabd33338c3c1212b">operations_research::atoi64</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="strtoint_8h_source.html#l00065">65</a> of file <a class="el" href="strtoint_8h_source.html">strtoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8089a62e9146eddbeda7c738d64b11e7"></a><!-- doxytag: member="operations_research::ContainsKey" ref="a8089a62e9146eddbeda7c738d64b11e7" args="(const Collection &amp;collection, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection , class Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceoperations__research.html#a8089a62e9146eddbeda7c738d64b11e7">operations_research::ContainsKey</a> </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test to see if a set, map, hash_set or hash_map contains a particular key. </p>
<p>Returns true if the key is in the collection. </p>

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00150">150</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac97f0609a50882b3039174657cfba21e"></a><!-- doxytag: member="operations_research::FindCopy" ref="ac97f0609a50882b3039174657cfba21e" args="(const Collection &amp;collection, const Key &amp;key, Value *const value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection , class Key , class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceoperations__research.html#ac97f0609a50882b3039174657cfba21e">operations_research::FindCopy</a> </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *const&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a lookup in map or hash_map. </p>
<p>If the key is present and value is non-NULL then a copy of the value associated with the key is made into *value. Returns whether key was present. </p>

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00134">134</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d111cf48eb7acbc8821ee84e04ac5d1"></a><!-- doxytag: member="operations_research::FindOrDie" ref="a0d111cf48eb7acbc8821ee84e04ac5d1" args="(const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type&amp; <a class="el" href="namespaceoperations__research.html#a0d111cf48eb7acbc8821ee84e04ac5d1">operations_research::FindOrDie</a> </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00157">157</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a268c0156a214b93179cc9cc3dbde36b3"></a><!-- doxytag: member="operations_research::FindOrNull" ref="a268c0156a214b93179cc9cc3dbde36b3" args="(const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type* <a class="el" href="namespaceoperations__research.html#a268c0156a214b93179cc9cc3dbde36b3">operations_research::FindOrNull</a> </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a lookup in a map or hash_map. </p>
<p>If the key is present a const pointer to the associated value is returned, otherwise a NULL pointer is returned. </p>

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00042">42</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90be3316458c80e031f84cc65c5fdb45"></a><!-- doxytag: member="operations_research::FindOrNull" ref="a90be3316458c80e031f84cc65c5fdb45" args="(Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Collection::value_type::second_type* <a class="el" href="namespaceoperations__research.html#a268c0156a214b93179cc9cc3dbde36b3">operations_research::FindOrNull</a> </td>
          <td>(</td>
          <td class="paramtype">Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a lookup in a map or hash_map. </p>
<p>Same as above but the returned pointer is not const and can be used to change the stored value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>NOLINT </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00056">56</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="af39d408f617b103493963ea1603222ac"></a><!-- doxytag: member="operations_research::FindPtrOrNull" ref="af39d408f617b103493963ea1603222ac" args="(const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type <a class="el" href="namespaceoperations__research.html#af39d408f617b103493963ea1603222ac">operations_research::FindPtrOrNull</a> </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a lookup in a map or hash_map whose values are pointers. </p>
<p>If the key is present a const pointer to the associated value is returned, otherwise a NULL pointer is returned. This function does not distinguish between a missing key and a key mapped to a NULL value. </p>

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00072">72</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa4c61ca91d4d67f0dcb250fd0471e159"></a><!-- doxytag: member="operations_research::FindWithDefault" ref="aa4c61ca91d4d67f0dcb250fd0471e159" args="(const Collection &amp;collection, const typename Collection::value_type::first_type &amp;key, const typename Collection::value_type::second_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Collection::value_type::second_type&amp; <a class="el" href="namespaceoperations__research.html#aa4c61ca91d4d67f0dcb250fd0471e159">operations_research::FindWithDefault</a> </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::second_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a lookup in a map or hash_map. </p>
<p>If the key is present in the map then the value associated with that key is returned, otherwise the value passed as a default is returned. </p>

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00027">27</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="af7311bc7b29234833be481c3b9a06448"></a><!-- doxytag: member="operations_research::GetProcessMemoryUsage" ref="af7311bc7b29234833be481c3b9a06448" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> <a class="el" href="namespaceoperations__research.html#af7311bc7b29234833be481c3b9a06448">operations_research::GetProcessMemoryUsage</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GetProcessMemoryUsage. </p>
<p>Returns the memory usage of the process.</p>
<p>Mac OS X LINUX WINDOWS &lt; Unknown, returning 0. </p>

<p>Definition at line <a class="el" href="sysinfo_8cc_source.html#l00078">78</a> of file <a class="el" href="sysinfo_8cc_source.html">sysinfo.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa6647370e5e668a4a79c09d0e3269639"></a><!-- doxytag: member="operations_research::HasSuffixString" ref="aa6647370e5e668a4a79c09d0e3269639" args="(const StringPiece &amp;str, const StringPiece &amp;suffix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceoperations__research.html#aa6647370e5e668a4a79c09d0e3269639">operations_research::HasSuffixString</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespaceoperations__research.html#aa6647370e5e668a4a79c09d0e3269639" title="HasSuffixString() Return true if str ends in suffix.">HasSuffixString()</a> Return true if str ends in suffix. </p>

<p>Definition at line <a class="el" href="strutil_8h_source.html#l00026">26</a> of file <a class="el" href="strutil_8h_source.html">strutil.h</a>.</p>

</div>
</div>
<a class="anchor" id="a42128d077e0c967c2cb5ada122b9c91c"></a><!-- doxytag: member="operations_research::InsertIfNotPresent" ref="a42128d077e0c967c2cb5ada122b9c91c" args="(Collection *const collection, const Key &amp;key, const Value &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection , class Key , class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceoperations__research.html#a42128d077e0c967c2cb5ada122b9c91c">operations_research::InsertIfNotPresent</a> </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a new key and value into a map or hash_map. </p>
<p>If the key is not present in the map the key and value are inserted, otherwise nothing happens. True indicates that an insert took place, false indicates the key was already present. </p>

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00103">103</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a16996799c1008f29cd33da7d9366eb72"></a><!-- doxytag: member="operations_research::InsertOrDie" ref="a16996799c1008f29cd33da7d9366eb72" args="(Collection *const collection, const typename Collection::value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#a16996799c1008f29cd33da7d9366eb72">operations_research::InsertOrDie</a> </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts a new pair&lt;key,value&gt; into a map or hash_map. </p>
<p>Insert a new key into a set or hash_set. Dies if the key is already present. </p>

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00114">114</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a478de9d531f4fe53368ce2e29c7c5cf3"></a><!-- doxytag: member="operations_research::InsertOrDie" ref="a478de9d531f4fe53368ce2e29c7c5cf3" args="(Collection *const collection, const typename Collection::value_type::first_type &amp;key, const typename Collection::value_type::second_type &amp;data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#a16996799c1008f29cd33da7d9366eb72">operations_research::InsertOrDie</a> </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::first_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Collection::value_type::second_type &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts a new key/value into a map or hash_map. </p>
<p>Dies if the key is already present. </p>

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00122">122</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="adc393a0cc02feb79f7860333d7a009e7"></a><!-- doxytag: member="operations_research::InsertOrUpdate" ref="adc393a0cc02feb79f7860333d7a009e7" args="(Collection *const collection, const Key &amp;key, const Value &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Collection , class Key , class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceoperations__research.html#adc393a0cc02feb79f7860333d7a009e7">operations_research::InsertOrUpdate</a> </td>
          <td>(</td>
          <td class="paramtype">Collection *const&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the value associated with a particular key in a map or hash_map. </p>
<p>If the key is not present in the map the key and value are inserted, otherwise the value is updated to be a copy of the value provided. True indicates that an insert took place, false indicates an update. </p>

<p>Definition at line <a class="el" href="map-util_8h_source.html#l00086">86</a> of file <a class="el" href="map-util_8h_source.html">map-util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a065344c7f102397737a0dcaaf47da6e9"></a><!-- doxytag: member="operations_research::make_scoped_ptr" ref="a065344c7f102397737a0dcaaf47da6e9" args="(C *param)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1scoped__ptr.html">scoped_ptr</a>&lt; C &gt; <a class="el" href="namespaceoperations__research.html#a065344c7f102397737a0dcaaf47da6e9">operations_research::make_scoped_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="scoped__ptr_8h_source.html#l00144">144</a> of file <a class="el" href="scoped__ptr_8h_source.html">scoped_ptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae3eb78859f8162620f6fffe8cac690af"></a><!-- doxytag: member="operations_research::mix" ref="ae3eb78859f8162620f6fffe8cac690af" args="(uint32 &amp;a, uint32 &amp;b, uint32 &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespaceoperations__research.html#ae3eb78859f8162620f6fffe8cac690af">operations_research::mix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integral__types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integral__types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integral__types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="hash_8h_source.html#l00034">34</a> of file <a class="el" href="hash_8h_source.html">hash.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5cdda52220787f2b0cf8273197012f26"></a><!-- doxytag: member="operations_research::mix" ref="a5cdda52220787f2b0cf8273197012f26" args="(uint64 &amp;a, uint64 &amp;b, uint64 &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespaceoperations__research.html#ae3eb78859f8162620f6fffe8cac690af">operations_research::mix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integral__types_8h.html#a29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integral__types_8h.html#a29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integral__types_8h.html#a29940ae63ec06c9998bba873e25407ad">uint64</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="hash_8h_source.html#l00046">46</a> of file <a class="el" href="hash_8h_source.html">hash.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad9445658a5550f610625680acd2fcec6"></a><!-- doxytag: member="operations_research::operator!=" ref="ad9445658a5550f610625680acd2fcec6" args="(C *p1, const scoped_ptr&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator!= </td>
          <td>(</td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_ptr&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="scoped__ptr_8h_source.html#l00139">139</a> of file <a class="el" href="scoped__ptr_8h_source.html">scoped_ptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9657706be552d9e051e8cc6cd68537c"></a><!-- doxytag: member="operations_research::operator!=" ref="aa9657706be552d9e051e8cc6cd68537c" args="(C *p1, const scoped_array&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator!= </td>
          <td>(</td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_array&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="scoped__ptr_8h_source.html#l00253">253</a> of file <a class="el" href="scoped__ptr_8h_source.html">scoped_ptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a11fee38a4ffa51cb60cf7dd07d4ded50"></a><!-- doxytag: member="operations_research::operator!=" ref="a11fee38a4ffa51cb60cf7dd07d4ded50" args="(C *p, const scoped_ptr_malloc&lt; C, FP &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class FP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator!= </td>
          <td>(</td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_ptr_malloc&lt; C, FP &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="scoped__ptr_8h_source.html#l00373">373</a> of file <a class="el" href="scoped__ptr_8h_source.html">scoped_ptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a59b54a8f597419873fb3f1b876965dbf"></a><!-- doxytag: member="operations_research::operator==" ref="a59b54a8f597419873fb3f1b876965dbf" args="(C *p1, const scoped_ptr&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator== </td>
          <td>(</td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_ptr&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="scoped__ptr_8h_source.html#l00134">134</a> of file <a class="el" href="scoped__ptr_8h_source.html">scoped_ptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="af3c8edb4fcf89de5549ae96a56e266c2"></a><!-- doxytag: member="operations_research::operator==" ref="af3c8edb4fcf89de5549ae96a56e266c2" args="(C *p1, const scoped_array&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator== </td>
          <td>(</td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_array&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="scoped__ptr_8h_source.html#l00248">248</a> of file <a class="el" href="scoped__ptr_8h_source.html">scoped_ptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeb180cb495a29f70abe18b9f504b56ed"></a><!-- doxytag: member="operations_research::operator==" ref="aeb180cb495a29f70abe18b9f504b56ed" args="(C *p, const scoped_ptr_malloc&lt; C, FP &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class FP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::operator== </td>
          <td>(</td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scoped_ptr_malloc&lt; C, FP &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="scoped__ptr_8h_source.html#l00368">368</a> of file <a class="el" href="scoped__ptr_8h_source.html">scoped_ptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a08b84c3f7aa7f7488210416a1a6530f9"></a><!-- doxytag: member="operations_research::RunWorker" ref="a08b84c3f7aa7f7488210416a1a6530f9" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#a08b84c3f7aa7f7488210416a1a6530f9">operations_research::RunWorker</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="threadpool_8cc_source.html#l00021">21</a> of file <a class="el" href="threadpool_8cc_source.html">threadpool.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0008d35d0b2da9a367c5e59645ce989b"></a><!-- doxytag: member="operations_research::SplitStringToIteratorUsing" ref="a0008d35d0b2da9a367c5e59645ce989b" args="(const std::string &amp;full, const char *delim, ITR &amp;result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ITR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespaceoperations__research.html#a0008d35d0b2da9a367c5e59645ce989b">operations_research::SplitStringToIteratorUsing</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>full</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ITR &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespaceoperations__research.html#a9ebe475d14950a152d76183cbc9d6b84" title="SplitStringUsing() Split a string using a character delimiter.">SplitStringUsing()</a> Split a string using a character delimiter. </p>
<p>Append the components to 'result'.</p>
<p>Note: For multi-character delimiters, this routine will split on *ANY* of the characters in the string, not the entire string as a single delimiter. </p>

<p>Definition at line <a class="el" href="split_8cc_source.html#l00030">30</a> of file <a class="el" href="split_8cc_source.html">split.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9ebe475d14950a152d76183cbc9d6b84"></a><!-- doxytag: member="operations_research::SplitStringUsing" ref="a9ebe475d14950a152d76183cbc9d6b84" args="(const std::string &amp;full, const char *delim, std::vector&lt; std::string &gt; *res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#a9ebe475d14950a152d76183cbc9d6b84">operations_research::SplitStringUsing</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>full</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespaceoperations__research.html#a9ebe475d14950a152d76183cbc9d6b84" title="SplitStringUsing() Split a string using a character delimiter.">SplitStringUsing()</a> Split a string using a character delimiter. </p>
<p>Append the components to 'result'. If there are consecutive delimiters, this function skips over all of them. </p>

<p>Definition at line <a class="el" href="split_8cc_source.html#l00063">63</a> of file <a class="el" href="split_8cc_source.html">split.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a253b1c2056075b651fa4b2dd751c8c5e"></a><!-- doxytag: member="operations_research::SStringPrintf" ref="a253b1c2056075b651fa4b2dd751c8c5e" args="(std::string *const dst, const char *const format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#a253b1c2056075b651fa4b2dd751c8c5e">operations_research::SStringPrintf</a> </td>
          <td>(</td>
          <td class="paramtype">std::string *const&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="stringprintf_8cc_source.html#l00087">87</a> of file <a class="el" href="stringprintf_8cc_source.html">stringprintf.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad00841377d86b0e0e99128ce0b8575d3"></a><!-- doxytag: member="operations_research::STLDeleteContainerPairSecondPointers" ref="ad00841377d86b0e0e99128ce0b8575d3" args="(ForwardIterator begin, ForwardIterator end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#ad00841377d86b0e0e99128ce0b8575d3">operations_research::STLDeleteContainerPairSecondPointers</a> </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespaceoperations__research.html#ad00841377d86b0e0e99128ce0b8575d3" title="STLDeleteContainerPairSecondPointers() For a range within a container of pairs, calls delete (non-arr...">STLDeleteContainerPairSecondPointers()</a> For a range within a container of pairs, calls delete (non-array version) on the SECOND item in the pairs. </p>
<p>NOTE: Like STLDeleteContainerPointers, deleting behind the iterator. Deleting the value does not always invalidate the iterator, but it may do so if the key is a pointer into the value object. </p>

<p>Definition at line <a class="el" href="stl__util_8h_source.html#l00048">48</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa90b22933d5e03746df76247ec43a9e"></a><!-- doxytag: member="operations_research::STLDeleteContainerPointers" ref="afa90b22933d5e03746df76247ec43a9e" args="(ForwardIterator begin, ForwardIterator end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#afa90b22933d5e03746df76247ec43a9e">operations_research::STLDeleteContainerPointers</a> </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespaceoperations__research.html#afa90b22933d5e03746df76247ec43a9e" title="STLDeleteContainerPointers() For a range within a container of pointers, calls delete (non-array vers...">STLDeleteContainerPointers()</a> For a range within a container of pointers, calls delete (non-array version) on these pointers. </p>
<p>NOTE: for these three functions, we could just implement a DeleteObject functor and then call for_each() on the range and functor, but this requires us to pull in all of algorithm.h, which seems expensive. For hash_[multi]set, it is important that this deletes behind the iterator because the hash_set may call the hash function on the iterator when it is advanced, which could result in the hash function trying to deference a stale pointer. </p>

<p>Definition at line <a class="el" href="stl__util_8h_source.html#l00032">32</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7f9ba4929d05cd9e1ccacefceac78692"></a><!-- doxytag: member="operations_research::STLDeleteElements" ref="a7f9ba4929d05cd9e1ccacefceac78692" args="(T *container)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#a7f9ba4929d05cd9e1ccacefceac78692">operations_research::STLDeleteElements</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespaceoperations__research.html#a7f9ba4929d05cd9e1ccacefceac78692" title="STLDeleteElements() deletes all the elements in an STL container and clears the container.">STLDeleteElements()</a> deletes all the elements in an STL container and clears the container. </p>
<p>This function is suitable for use with a vector, set, hash_set, or any other STL container which defines sensible begin(), end(), and clear() methods.</p>
<p>If container is NULL, this function is a no-op.</p>
<p>As an alternative to calling <a class="el" href="namespaceoperations__research.html#a7f9ba4929d05cd9e1ccacefceac78692" title="STLDeleteElements() deletes all the elements in an STL container and clears the container.">STLDeleteElements()</a> directly, consider ElementDeleter (defined below), which ensures that your container's elements are deleted when the ElementDeleter goes out of scope. </p>

<p>Definition at line <a class="el" href="stl__util_8h_source.html#l00088">88</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a18abaa8dded040fd7781e7c03f537443"></a><!-- doxytag: member="operations_research::STLDeleteValues" ref="a18abaa8dded040fd7781e7c03f537443" args="(T *v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#a18abaa8dded040fd7781e7c03f537443">operations_research::STLDeleteValues</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an STL container consisting of (key, value) pairs, STLDeleteValues deletes all the "value" components and clears the container. </p>
<p>Does nothing in the case it's given a NULL pointer. </p>

<p>Definition at line <a class="el" href="stl__util_8h_source.html#l00099">99</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaea180392c576a0712d14ae2e210d80d"></a><!-- doxytag: member="operations_research::STLStringResizeUninitialized" ref="aaea180392c576a0712d14ae2e210d80d" args="(std::string *s, size_t new_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#aaea180392c576a0712d14ae2e210d80d">operations_research::STLStringResizeUninitialized</a> </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="stl__util_8h_source.html#l00057">57</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa20b89a75a7ba6a894d4771eae8cc192"></a><!-- doxytag: member="operations_research::StrCat" ref="aa20b89a75a7ba6a894d4771eae8cc192" args="(const StringPiece &amp;p1, const StringPiece &amp;p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceoperations__research.html#aa20b89a75a7ba6a894d4771eae8cc192">operations_research::StrCat</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>StrCat. </p>

<p>Definition at line <a class="el" href="join_8cc_source.html#l00021">21</a> of file <a class="el" href="join_8cc_source.html">join.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a61ddd7dde406cb842e1f60cbc82364ef"></a><!-- doxytag: member="operations_research::StrCat" ref="a61ddd7dde406cb842e1f60cbc82364ef" args="(const StringPiece &amp;p1, const StringPiece &amp;p2, const StringPiece &amp;p3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceoperations__research.html#aa20b89a75a7ba6a894d4771eae8cc192">operations_research::StrCat</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="join_8cc_source.html#l00027">27</a> of file <a class="el" href="join_8cc_source.html">join.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0599ef161abcafe4421df90ff0848fdf"></a><!-- doxytag: member="operations_research::StrCat" ref="a0599ef161abcafe4421df90ff0848fdf" args="(const StringPiece &amp;p1, const StringPiece &amp;p2, const StringPiece &amp;p3, const StringPiece &amp;p4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceoperations__research.html#aa20b89a75a7ba6a894d4771eae8cc192">operations_research::StrCat</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="join_8cc_source.html#l00036">36</a> of file <a class="el" href="join_8cc_source.html">join.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad5b5fc9be061d23eed98bd2b04c95203"></a><!-- doxytag: member="operations_research::StrCat" ref="ad5b5fc9be061d23eed98bd2b04c95203" args="(const StringPiece &amp;p1, const StringPiece &amp;p2, const StringPiece &amp;p3, const StringPiece &amp;p4, const StringPiece &amp;p5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceoperations__research.html#aa20b89a75a7ba6a894d4771eae8cc192">operations_research::StrCat</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="join_8cc_source.html#l00047">47</a> of file <a class="el" href="join_8cc_source.html">join.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa4b2e584cc91e80c7ab8a264624f015a"></a><!-- doxytag: member="operations_research::StrCat" ref="aa4b2e584cc91e80c7ab8a264624f015a" args="(int64 a1, const StringPiece &amp;p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceoperations__research.html#aa20b89a75a7ba6a894d4771eae8cc192">operations_research::StrCat</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="join_8cc_source.html#l00060">60</a> of file <a class="el" href="join_8cc_source.html">join.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a164ab8a796555d2eb3d18ff5c2725ec9"></a><!-- doxytag: member="operations_research::StrCat" ref="a164ab8a796555d2eb3d18ff5c2725ec9" args="(const StringPiece &amp;p1, int64 a2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceoperations__research.html#aa20b89a75a7ba6a894d4771eae8cc192">operations_research::StrCat</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="join_8cc_source.html#l00064">64</a> of file <a class="el" href="join_8cc_source.html">join.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad0becae3367393311c214235572bc3b5"></a><!-- doxytag: member="operations_research::string_as_array" ref="ad0becae3367393311c214235572bc3b5" args="(std::string *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="namespaceoperations__research.html#ad0becae3367393311c214235572bc3b5">operations_research::string_as_array</a> </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a mutable char* pointing to a string's internal buffer, which may not be null-terminated. </p>
<p>Writing through this pointer will modify the string.</p>
<p>string_as_array(&amp;str)[i] is valid for 0 &lt;= i &lt; str.size() until the next call to a string method that invalidates iterators.</p>
<p>As of 2006-04, there is no standard-blessed way of getting a mutable reference to a string's internal buffer. However, issue 530 (<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#530">http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#530</a>) proposes this as the method. According to Matt Austern, this should already work on all current implementations. </p>

<p>Definition at line <a class="el" href="stl__util_8h_source.html#l00073">73</a> of file <a class="el" href="stl__util_8h_source.html">stl_util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a476dd09521b9566e36de70e849dac4ec"></a><!-- doxytag: member="operations_research::StringAppendF" ref="a476dd09521b9566e36de70e849dac4ec" args="(std::string *const dst, const char *const format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#a476dd09521b9566e36de70e849dac4ec">operations_research::StringAppendF</a> </td>
          <td>(</td>
          <td class="paramtype">std::string *const&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="stringprintf_8cc_source.html#l00095">95</a> of file <a class="el" href="stringprintf_8cc_source.html">stringprintf.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a387611e37af188c1863d74ff2c8a986c"></a><!-- doxytag: member="operations_research::StringAppendV" ref="a387611e37af188c1863d74ff2c8a986c" args="(std::string *const dst, const char *const format, va_list ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#a387611e37af188c1863d74ff2c8a986c">operations_research::StringAppendV</a> </td>
          <td>(</td>
          <td class="paramtype">std::string *const&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="stringprintf_8cc_source.html#l00023">23</a> of file <a class="el" href="stringprintf_8cc_source.html">stringprintf.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a912395124d379d117a6d9c71d2ffbad7"></a><!-- doxytag: member="operations_research::StringPrintf" ref="a912395124d379d117a6d9c71d2ffbad7" args="(const char *const format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespaceoperations__research.html#a912395124d379d117a6d9c71d2ffbad7">operations_research::StringPrintf</a> </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="stringprintf_8cc_source.html#l00078">78</a> of file <a class="el" href="stringprintf_8cc_source.html">stringprintf.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac31ca97c330da20f6082581dc81f418e"></a><!-- doxytag: member="operations_research::strto32" ref="ac31ca97c330da20f6082581dc81f418e" args="(const char *nptr, char **endptr, int base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integral__types_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> <a class="el" href="namespaceoperations__research.html#ac31ca97c330da20f6082581dc81f418e">operations_research::strto32</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Conversions to a 32-bit integer can pass the call to strto[u]l on 32-bit platforms, but need a little extra work on 64-bit platforms. </p>

<p>Definition at line <a class="el" href="strtoint_8h_source.html#l00024">24</a> of file <a class="el" href="strtoint_8h_source.html">strtoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="a39284ed8b31adbf1e6a6fa1cebb43947"></a><!-- doxytag: member="operations_research::strto64" ref="a39284ed8b31adbf1e6a6fa1cebb43947" args="(const char *nptr, char **endptr, int base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integral__types_8h.html#aecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> <a class="el" href="namespaceoperations__research.html#a39284ed8b31adbf1e6a6fa1cebb43947">operations_research::strto64</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For now, long long is 64-bit on all the platforms we care about, so these functions can simply pass the call to strto[u]ll. </p>

<p>Definition at line <a class="el" href="strtoint_8h_source.html#l00034">34</a> of file <a class="el" href="strtoint_8h_source.html">strtoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="af0e0204225583d7b1bffcc304b268351"></a><!-- doxytag: member="operations_research::strtou32" ref="af0e0204225583d7b1bffcc304b268351" args="(const char *nptr, char **endptr, int base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integral__types_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="el" href="namespaceoperations__research.html#af0e0204225583d7b1bffcc304b268351">operations_research::strtou32</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="strtoint_8h_source.html#l00028">28</a> of file <a class="el" href="strtoint_8h_source.html">strtoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae7f177b4770b82039484d843a83b41e0"></a><!-- doxytag: member="operations_research::strtou64" ref="ae7f177b4770b82039484d843a83b41e0" args="(const char *nptr, char **endptr, int base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="integral__types_8h.html#a29940ae63ec06c9998bba873e25407ad">uint64</a> <a class="el" href="namespaceoperations__research.html#ae7f177b4770b82039484d843a83b41e0">operations_research::strtou64</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="strtoint_8h_source.html#l00042">42</a> of file <a class="el" href="strtoint_8h_source.html">strtoint.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad02f6e959876060c48ed92a457425943"></a><!-- doxytag: member="operations_research::swap" ref="ad02f6e959876060c48ed92a457425943" args="(scoped_ptr&lt; C &gt; &amp;p1, scoped_ptr&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#ad02f6e959876060c48ed92a457425943">operations_research::swap</a> </td>
          <td>(</td>
          <td class="paramtype">scoped_ptr&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scoped_ptr&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free functions. </p>

<p>Definition at line <a class="el" href="scoped__ptr_8h_source.html#l00129">129</a> of file <a class="el" href="scoped__ptr_8h_source.html">scoped_ptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7cc8b9fe79bcfca8715d0fca0e29614"></a><!-- doxytag: member="operations_research::swap" ref="ab7cc8b9fe79bcfca8715d0fca0e29614" args="(scoped_array&lt; C &gt; &amp;p1, scoped_array&lt; C &gt; &amp;p2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#ad02f6e959876060c48ed92a457425943">operations_research::swap</a> </td>
          <td>(</td>
          <td class="paramtype">scoped_array&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scoped_array&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free functions. </p>

<p>Definition at line <a class="el" href="scoped__ptr_8h_source.html#l00243">243</a> of file <a class="el" href="scoped__ptr_8h_source.html">scoped_ptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a47a5ddd3ca135251e66b6dcb5953e33a"></a><!-- doxytag: member="operations_research::swap" ref="a47a5ddd3ca135251e66b6dcb5953e33a" args="(scoped_ptr_malloc&lt; C, FP &gt; &amp;a, scoped_ptr_malloc&lt; C, FP &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class FP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceoperations__research.html#ad02f6e959876060c48ed92a457425943">operations_research::swap</a> </td>
          <td>(</td>
          <td class="paramtype">scoped_ptr_malloc&lt; C, FP &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scoped_ptr_malloc&lt; C, FP &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="scoped__ptr_8h_source.html#l00363">363</a> of file <a class="el" href="scoped__ptr_8h_source.html">scoped_ptr.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa7818e79e87d3c93e8607edad3c5b643"></a><!-- doxytag: member="operations_research::ThreadSafeIncrement" ref="aa7818e79e87d3c93e8607edad3c5b643" args="(T *value, Mutex *sm, TT inc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceoperations__research.html#aa7818e79e87d3c93e8607edad3c5b643">operations_research::ThreadSafeIncrement</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mutex *&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TT&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="synchronization_8h_source.html#l00051">51</a> of file <a class="el" href="synchronization_8h_source.html">synchronization.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


  <!-- Start of footer. -->
  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <tr valign=top>
      <td colspan=2 height=10></td>
    </tr>
    <tr valign=top>
      <td colspan=2 bgcolor=#992252 height=3></td>
    </tr>
  </table>

  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br />

  
  </body>
</html>
