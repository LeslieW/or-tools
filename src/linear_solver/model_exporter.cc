// Copyright 2010-2013 Google
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#include "linear_solver/model_exporter.h"

#include <cmath>
#include <cstddef>
#include <limits>
#include <utility>

#include "base/integral_types.h"
#include "base/logging.h"
#include "base/stringprintf.h"
#include "base/strutil.h"
#include "base/concise_iterator.h"
#include "base/map-util.h"
#include "linear_solver/linear_solver.h"
#include "linear_solver/linear_solver.pb.h"

#if defined(_MSC_VER)
#define isnan(x) _isnan(x)
static inline double round(double val) {
  return floor(val + 0.5);
}
#elif defined(__APPLE__)
using std::isnan;
#endif

namespace operations_research {

MPModelProtoExporter::MPModelProtoExporter(const MPModelProto& proto) :
  proto_(proto),
  var_id_to_index_map_(),
  num_integer_variables_(0),
  num_binary_variables_(0),
  num_continuous_variables_(0),
  num_digits_for_variables_(0),
  num_digits_for_constraints_(0),
  current_mps_column_(0),
  use_fixed_mps_format_(false),
  use_obfuscated_names_(false),
  setup_done_(false) {
}

// Note(user): This method is static. It is also used by MPSolver.
bool MPModelProtoExporter::CheckNameValidity(const string& name) {
  if (name.empty()) {
    LOG(WARNING) << "CheckNameValidity() should not be passed an empty name.";
    return false;
  }
  // Allow names that conform to the LP and MPS format.
  const int kMaxNameLength = 255;
  if (name.size() > kMaxNameLength) {
    LOG(WARNING) << "Invalid name " << name
                 << ": length > " << kMaxNameLength << "."
                 << " Will be unable to write model to file.";
    return false;
  }
  const string kForbiddenChars = " +-*/<>=:\\";
  if (name.find_first_of(kForbiddenChars) != string::npos) {
    LOG(WARNING) << "Invalid name " << name
                 << " contains forbidden character: " << kForbiddenChars
                 << " or space."
                 << " Will be unable to write model to file.";
    return false;
  }
  const string kForbiddenFirstChars = "$.0123456789";
  if (kForbiddenFirstChars.find(name[0]) != string::npos) {
    LOG(WARNING) << "Invalid name " << name
                 << ". First character is one of: " << kForbiddenFirstChars
                 << " Will be unable to write model to file.";
    return false;
  }
  return true;
}


string MPModelProtoExporter::GetVariableName(int var_index) const {
  const MPVariableProto& var_proto = proto_.variables(var_index);
  if (use_obfuscated_names_ || !var_proto.has_id()) {
    return StringPrintf("V%0*d", num_digits_for_variables_, var_index);
  } else {
    return var_proto.id();
  }
}

string MPModelProtoExporter::GetConstraintName(int cst_index) const {
  const MPConstraintProto& ct_proto = proto_.constraints(cst_index);
  if (use_obfuscated_names_ || !ct_proto.has_id()) {
    return StringPrintf("C%0*d", num_digits_for_constraints_, cst_index);
  } else {
    return ct_proto.id();
  }
}

void MPModelProtoExporter::AppendComments(
    const string& separator, string* output) const {
  const char* const sep = separator.c_str();
  StringAppendF(output, "%s Generated by MPModelProtoExporter\n", sep);
  StringAppendF(output, "%s   %-16s : %s\n", sep, "Name",
                proto_.has_name() ? proto_.name().c_str() : "NoName");
  StringAppendF(output, "%s   %-16s : %s\n", sep, "Format",
                use_fixed_mps_format_ ? "Fixed" : "Free");
  StringAppendF(output, "%s   %-16s : %d\n", sep, "Constraints",
                proto_.constraints_size());
  StringAppendF(output, "%s   %-16s : %d\n", sep, "Variables",
                proto_.variables_size());
  StringAppendF(output, "%s     %-14s : %d\n", sep, "Binary",
                num_binary_variables_);
  StringAppendF(output, "%s     %-14s : %d\n", sep, "Integer",
                num_integer_variables_);
  StringAppendF(output, "%s     %-14s : %d\n", sep, "Continuous",
                num_continuous_variables_);
}

bool MPModelProtoExporter::AppendLpTerm(const MPTermProto& term_proto,
                                        string* output) const {
  const string& id = term_proto.variable_id();
  const int var_index = FindWithDefault(var_id_to_index_map_, id, -1);
  if (var_index  == -1) {
    LOG(DFATAL) << "Reference to non-existent variable with id " << id;
    return false;
  }
  const string var_name = GetVariableName(var_index);
  const double coeff = term_proto.coefficient();
  if (coeff == 0.0) return true;
  StringAppendF(output, "%+.16G %-s ", coeff, var_name.c_str());
  return true;
}

bool MPModelProtoExporter::Setup() {
  num_digits_for_constraints_ =
      StringPrintf("%d", proto_.constraints_size()).size();
  num_digits_for_variables_ =
      StringPrintf("%d", proto_.variables_size()).size();
  num_binary_variables_ = 0;
  num_integer_variables_ = 0;
  var_id_to_index_map_.clear();
  for (int var_index = 0; var_index < proto_.variables_size(); ++var_index) {
    const MPVariableProto& var_proto = proto_.variables(var_index);
    const string& id = var_proto.id();
    if (!ContainsKey(var_id_to_index_map_, id)) {
      const double lb = var_proto.lb();
      const double ub = var_proto.ub();
      if (var_proto.integer()) {
        if (lb == 0.0 && ub == 1.0) {
          ++num_binary_variables_;
        } else {
          ++num_integer_variables_;
        }
      }
      var_id_to_index_map_[id] = var_index;
    } else {
     LOG(DFATAL) << "Duplicate variable id found: " << id;
     return false;
    }
  }
  num_continuous_variables_ = proto_.variables_size() - num_binary_variables_
                              - num_integer_variables_;
  return true;
}

bool MPModelProtoExporter::CheckAllNamesValidity() const {
  // Note: CheckNameValidity() takes care of the logging.
  for (int var_index = 0; var_index < proto_.variables_size(); ++var_index) {
    if (!CheckNameValidity(GetVariableName(var_index))) {
      return false;
    }
  }
  for (int cst_index = 0; cst_index < proto_.constraints_size(); ++cst_index) {
    if (!CheckNameValidity(GetConstraintName(cst_index))) {
      return false;
    }
  }
  return true;
}

bool MPModelProtoExporter::ExportModelAsLpFormat(bool obfuscated,
                                                 string* output) {
  // TODO(user):
  // - Sort constraints by category (implication, knapsack, logical or, etc...).

  if (!obfuscated && !CheckAllNamesValidity()) {
    return false;
  }
  if (!setup_done_) {
    if (!Setup()) {
      return false;
    }
  }
  setup_done_ = true;
  use_obfuscated_names_ = obfuscated;
  output->clear();

  // Comments section.
  AppendComments("\\", output);

  // Objective
  StringAppendF(output, proto_.maximize() ? "Maximize" : "Minimize");
  StringAppendF(output, "\n Obj: ");
  const double offset = proto_.has_objective_offset() ?
                        proto_.objective_offset() : 0.0;
  if (offset != 0.0) {
    StringAppendF(output, "%-+.16G Constant ", proto_.objective_offset());
  }
  for (int k = 0; k < proto_.objective_terms_size(); ++k) {
    if (!AppendLpTerm(proto_.objective_terms(k), output)) {
      return false;
    }
  }

  // Constraints
  StringAppendF(output, "\nSubject to\n");
  for (int cst_index = 0; cst_index < proto_.constraints_size(); ++cst_index) {
    const MPConstraintProto& ct_proto = proto_.constraints(cst_index);
    string term;
    for (int k = 0; k < ct_proto.terms_size(); ++k) {
      if (!AppendLpTerm(ct_proto.terms(k), &term)) {
        return false;
      }
    }
    const double lb = ct_proto.lb();
    const double ub = ct_proto.ub();
    string name = GetConstraintName(cst_index);
    if (lb == ub) {
      StringAppendF(output, " %s: %s = %-.16G\n",
                    name.c_str(), term.c_str(), ub);
    } else {
      if (ub != +std::numeric_limits<double>::infinity()) {
        string rhs_name = name;
        if (lb != -std::numeric_limits<double>::infinity()) {
          rhs_name += "_rhs";
        }
        StringAppendF(output, " %s: %s <= %-.16G\n",
                      rhs_name.c_str(), term.c_str(), ub);
      }
      if (lb != -std::numeric_limits<double>::infinity()) {
        string lhs_name = name;
        if (ub != +std::numeric_limits<double>::infinity()) {
          lhs_name += "_lhs";
        }
        StringAppendF(output, " %s: %s >= %-.16G\n",
                      lhs_name.c_str(), term.c_str(), lb);
      }
    }
  }

  // Bounds
  StringAppendF(output, "Bounds\n");
  if (offset != 0.0) {
    StringAppendF(output, " 1 <= Constant <= 1\n");
  }
  for (int var_index = 0; var_index < proto_.variables_size(); ++var_index) {
    const MPVariableProto& var_proto = proto_.variables(var_index);
    const double lb = var_proto.lb();
    const double ub = var_proto.ub();
    if (var_proto.integer() && lb == round(lb) && ub == round(ub)) {
     StringAppendF(output, " %.0f <= %s <= %.0f\n",
                    lb, GetVariableName(var_index).c_str(), ub);
    } else {
      if (lb != -std::numeric_limits<double>::infinity()) {
        StringAppendF(output, " %-.16G <= ", lb);
      }
      StringAppendF(output, "%s", GetVariableName(var_index).c_str());
      if (ub != std::numeric_limits<double>::infinity()) {
        StringAppendF(output, " <= %-.16G", ub);
      }
      StringAppendF(output, "\n");
    }
  }

  // Binaries
  if (num_binary_variables_ > 0) {
    StringAppendF(output, "Binaries\n");
    for (int var_index = 0; var_index < proto_.variables_size(); ++var_index) {
      const MPVariableProto& var_proto = proto_.variables(var_index);
      if (var_proto.integer()
          && var_proto.lb() == 0.0 && var_proto.ub() == 1.0) {
        StringAppendF(output, " %s\n", GetVariableName(var_index).c_str());
      }
    }
  }

  // Generals
  if (num_integer_variables_ > 0) {
    StringAppendF(output, "Generals\n");
    for (int var_index = 0; var_index < proto_.variables_size(); ++var_index) {
      const MPVariableProto& var_proto = proto_.variables(var_index);
      if (var_proto.integer()
          && (var_proto.lb() != 0.0 || var_proto.ub() != 1.0)) {
        StringAppendF(output, " %s\n", GetVariableName(var_index).c_str());
      }
    }
  }
  StringAppendF(output, "End\n");
  return true;
}

void MPModelProtoExporter::AppendMpsPair(
    const string& name, double value, string* output) const {
  const int kFixedMpsDoubleWidth = 12;
  if (use_fixed_mps_format_) {
    int precision = kFixedMpsDoubleWidth;
    string value_str = StringPrintf("%.*G", precision, value);
    // Use the largest precision that can fit into the field witdh.
    while (value_str.size() > kFixedMpsDoubleWidth) {
      --precision;
      value_str = StringPrintf("%.*G", precision, value);
    }
    StringAppendF(output, "  %-8s  %*s ",
                  name.c_str(), kFixedMpsDoubleWidth, value_str.c_str());
  } else {
    StringAppendF(output, "  %-16s  %21.16G ", name.c_str(), value);
  }
}

void MPModelProtoExporter::AppendMpsLineHeader(
    const string& id, const string& name, string* output) const {
  StringAppendF(output,
                use_fixed_mps_format_ ? " %-2s %-8s" : " %-2s  %-16s",
                id.c_str(), name.c_str());
}

void MPModelProtoExporter::AppendMpsLineHeaderWithNewLine(
    const string& id, const string& name, string* output) const {
  AppendMpsLineHeader(id, name, output);
  *output += "\n";
}


void MPModelProtoExporter::AppendMpsTermWithContext(
    const string& head_name, const string& name, double value, string* output) {
  if (current_mps_column_ == 0) {
    AppendMpsLineHeader("", head_name, output);
  }
  AppendMpsPair(name, value, output);
  AppendNewLineIfTwoColumns(output);
}

void MPModelProtoExporter::AppendMpsBound(
    const string& bound_type, const string& name, double value,
    string* output) const {
  AppendMpsLineHeader(bound_type, "BOUND", output);
  AppendMpsPair(name, value, output);
  *output += "\n";
}

void MPModelProtoExporter::AppendNewLineIfTwoColumns(string* output) {
  ++current_mps_column_;
  if (current_mps_column_ == 2) {
    *output += "\n";
    current_mps_column_ = 0;
  }
}

// Decide whether to use fixed- or free-form MPS format.
bool MPModelProtoExporter::CanUseFixedMpsFormat() const {
  const int kMpsFieldSize = 8;
  if (use_obfuscated_names_) {
    return num_digits_for_constraints_ < kMpsFieldSize
          && num_digits_for_variables_ < kMpsFieldSize;
  }
  for (int cst_index = 0; cst_index < proto_.constraints_size(); ++cst_index) {
    const MPConstraintProto& ct_proto = proto_.constraints(cst_index);
    const string& ct_id = ct_proto.id();
    if (ct_id.size() > kMpsFieldSize) {
      return false;
    }
  }
  for (int var_index = 0; var_index < proto_.variables_size(); ++var_index) {
    const MPVariableProto& var_proto = proto_.variables(var_index);
    const string& var_id = var_proto.id();
    if (var_id.size() > kMpsFieldSize) {
      return false;
    }
  }
  return true;
}

bool MPModelProtoExporter::ExportModelAsMpsFormat(bool fixed_format,
                                                  bool obfuscated,
                                                  string* output) {
  if (!obfuscated && !CheckAllNamesValidity()) {
    return false;
  }
  if (!setup_done_) {
    if (!Setup()) {
      return false;
    }
  }
  setup_done_ = true;
  use_obfuscated_names_ = obfuscated;
  use_fixed_mps_format_ = fixed_format;
  if (fixed_format && !CanUseFixedMpsFormat()) {
    LOG(WARNING) << "Cannot use fixed format. Falling back to free format";
    use_fixed_mps_format_ = false;
  }
  output->clear();

  // Comments.
  AppendComments("*", output);

  // NAME section.
  StringAppendF(output, "%-14s%s\n", "NAME", proto_.name().c_str());

  // ROWS section.
  current_mps_column_ = 0;
  string rows_section;
  AppendMpsLineHeaderWithNewLine("N", "COST", &rows_section);
  for (int cst_index = 0; cst_index < proto_.constraints_size(); ++cst_index) {
    const MPConstraintProto& ct_proto = proto_.constraints(cst_index);
    const double lb = ct_proto.lb();
    const double ub = ct_proto.ub();
    const string cst_name = GetConstraintName(cst_index);
    if (lb == ub && lb != 0.0) {
      AppendMpsLineHeaderWithNewLine("E", cst_name, &rows_section);
    } else if (lb == -std::numeric_limits<double>::infinity()) {
      DCHECK_NE(std::numeric_limits<double>::infinity(), ub);
      AppendMpsLineHeaderWithNewLine("L", cst_name, &rows_section);
    } else {
      DCHECK_NE(-std::numeric_limits<double>::infinity(), lb);
      AppendMpsLineHeaderWithNewLine("G", cst_name, &rows_section);
    }
  }
  if (!rows_section.empty()) {
    *output += "ROWS\n" + rows_section;
  }

  // As the information regarding a column needs to be contiguous, we create
  // a map associating a variable to a the vector containing the indices of the
  // constraints where this variable appears.
  std::vector<std::vector<pair<int, double> > > transpose(proto_.variables_size());
  for (int cst_index = 0; cst_index < proto_.constraints_size(); ++cst_index) {
    const MPConstraintProto& ct_proto = proto_.constraints(cst_index);
    for (int k = 0; k < ct_proto.terms_size(); ++k) {
      const MPTermProto& term_proto = ct_proto.terms(k);
      const string& id = term_proto.variable_id();
      const int var_index  = FindWithDefault(var_id_to_index_map_, id, -1);
      if (var_index == -1) {
        LOG(DFATAL) << "Non-existent variable with id " << id
                    << " used in constraint # " << cst_index << ".";
        return false;
      }
      const double coeff = term_proto.coefficient();
      if (coeff != 0.0) {
        transpose[var_index].push_back(pair<int, double>(cst_index, coeff));
      }
    }
  }
  for (int var_index = 0; var_index < proto_.variables_size(); ++var_index) {
    sort(transpose[var_index].begin(), transpose[var_index].end());
  }

  std::vector<double> objective(proto_.variables_size(), 0.0);
  for (int k = 0; k < proto_.objective_terms_size(); ++k) {
    const MPTermProto& term_proto = proto_.objective_terms(k);
    const string& id = term_proto.variable_id();
    const int var_index  = FindWithDefault(var_id_to_index_map_, id, -1);
    if (var_index == -1) {
      LOG(DFATAL) << "Non-existent variable with id " << id
                  << " used in objective.";
      return false;
    }
    objective[var_index] = term_proto.coefficient();
  }

  // COLUMNS section.
  current_mps_column_ = 0;
  string columns_section;
  const char* const kIntMarkerFormat = "  %-10s%-36s%-10s\n";
  for (int var_index = 0; var_index < proto_.variables_size(); ++var_index) {
    const MPVariableProto& var_proto = proto_.variables(var_index);
    const string var_name = GetVariableName(var_index);
    current_mps_column_ = 0;
    if (var_proto.integer()) {
      StringAppendF(&columns_section, kIntMarkerFormat,
                                      "INTSTART", "'MARKER'", "'INTORG'");
    }
    const double objective_coef = objective[var_index];
    if (objective_coef != 0.0) {
      AppendMpsTermWithContext(
          var_name, "COST", objective_coef, &columns_section);
    }
    for (int k = 0; k < transpose[var_index].size(); ++k) {
      const pair<int, double> p = transpose[var_index][k];
      const int cst_index = p.first;
      const double coeff = p.second;
      const string cst_name = GetConstraintName(cst_index);
      AppendMpsTermWithContext(
          var_name, cst_name, coeff, &columns_section);
    }
    if (var_proto.integer()) {
      columns_section += "\n";
      current_mps_column_ = 0;
      StringAppendF(&columns_section, kIntMarkerFormat,
                                      "INTEND", "'MARKER'", "'INTEND'");
    }
    AppendNewLineIfTwoColumns(&columns_section);
  }
  if (!columns_section.empty()) {
    *output += "COLUMNS\n" + columns_section;
  }

  // RHS (right-hand-side) section.
  current_mps_column_ = 0;
  string rhs_section;
  for (int cst_index = 0; cst_index < proto_.constraints_size(); ++cst_index) {
    const MPConstraintProto& ct_proto = proto_.constraints(cst_index);
    const double lb = ct_proto.lb();
    const double ub = ct_proto.ub();
    const string cst_name = GetConstraintName(cst_index);
    if (lb != -std::numeric_limits<double>::infinity()) {
      AppendMpsTermWithContext("RHS", cst_name, lb, &rhs_section);
    } else if (ub != +std::numeric_limits<double>::infinity()) {
      AppendMpsTermWithContext("RHS", cst_name, ub, &rhs_section);
    }
  }
  AppendNewLineIfTwoColumns(&rhs_section);
  if (!rhs_section.empty()) {
    *output += "RHS\n" + rhs_section;
  }

  // RANGES section.
  current_mps_column_ = 0;
  string ranges_section;
  for (int cst_index = 0; cst_index < proto_.constraints_size(); ++cst_index) {
    const MPConstraintProto& ct_proto = proto_.constraints(cst_index);
    const double range = fabs(ct_proto.ub() - ct_proto.lb());
    if (range != 0.0 && range != +std::numeric_limits<double>::infinity()) {
      const string cst_name = GetConstraintName(cst_index);
      AppendMpsTermWithContext("RANGE", cst_name, range, &ranges_section);
    }
  }
  AppendNewLineIfTwoColumns(&ranges_section);
  if (!ranges_section.empty()) {
    *output += "RANGES\n" + ranges_section;
  }

  // BOUNDS section.
  current_mps_column_ = 0;
  string bounds_section;
  for (int var_index = 0; var_index < proto_.variables_size(); ++var_index) {
    const MPVariableProto& var_proto = proto_.variables(var_index);
    const double lb = var_proto.lb();
    const double ub = var_proto.ub();
    const string var_name = GetVariableName(var_index);
    if (var_proto.integer()) {
      if (lb == 0.0 && ub == 1.0) {
        AppendMpsLineHeader("BV", "BOUND", &bounds_section);
        StringAppendF(&bounds_section, "  %s\n", var_name.c_str());
      } else {
        if (lb != 0.0) {
          AppendMpsBound("LI", var_name, lb, &bounds_section);
        }
        if (ub != +std::numeric_limits<double>::infinity()) {
          AppendMpsBound("UI", var_name, ub, &bounds_section);
        }
      }
    } else {
      if (lb == -std::numeric_limits<double>::infinity()
          && ub == +std::numeric_limits<double>::infinity()) {
        AppendMpsLineHeader("FR", "BOUND", &bounds_section);
        StringAppendF(&bounds_section, "  %s\n", var_name.c_str());
      } else if (lb == ub) {
        AppendMpsBound("FX", var_name, lb, &bounds_section);
      } else {
        if (lb != 0.0) {
          AppendMpsBound("LO", var_name, lb, &bounds_section);
        } else if (ub == +std::numeric_limits<double>::infinity()) {
          AppendMpsLineHeader("PL", "BOUND", &bounds_section);
          StringAppendF(&bounds_section, "  %s\n", var_name.c_str());
        }
        if (ub != +std::numeric_limits<double>::infinity()) {
          AppendMpsBound("UP", var_name, ub, &bounds_section);
        }
      }
    }
  }
  if (!bounds_section.empty()) {
    *output += "BOUNDS\n" + bounds_section;
  }

  *output += "ENDATA\n";
  return true;
}

}  // namespace operations_research
