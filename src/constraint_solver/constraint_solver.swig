// Copyright 2010-2012 Google
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

%include exception.i
%include util/data.swig
%include util/util.swig

// Include the file we want to wrap a first time.
#ifdef SWIGPYTHON
%{
#include <setjmp.h>

#include "constraint_solver/constraint_solver.h"
#include "constraint_solver/constraint_solveri.h"

DECLARE_bool(cp_trace_propagation);
DECLARE_bool(cp_print_model);
DECLARE_bool(cp_model_stats);
DECLARE_string(cp_export_file);
DECLARE_bool(cp_no_solve);
DECLARE_string(cp_profile_file);

struct FailureProtect {
  jmp_buf exception_buffer;
  void JumpBack() {
    longjmp(exception_buffer, 1);
  }
};

namespace operations_research {
class CallPyDecisionBuilder : public DecisionBuilder {
 public:
  CallPyDecisionBuilder(PyObject* pydb) : pysolver_(NULL), pyarg_(NULL) {
    Py_INCREF(pydb);
    pydb_ = pydb;
    func_ = PyObject_GetAttrString(pydb_, "NextWrapper");
    Py_XINCREF(func_);
    str_func_ = PyObject_GetAttrString(pydb_, "DebugString");
    Py_XINCREF(str_func_);
  }

  virtual ~CallPyDecisionBuilder() {
    Py_DECREF(pydb_);
    pydb_ = NULL;
    Py_XDECREF(func_);
    func_ = NULL;
    Py_XDECREF(str_func_);
    str_func_ = NULL;
    Py_XDECREF(pysolver_);
    pysolver_ = NULL;
    Py_XDECREF(pyarg_);
    pyarg_ = NULL;
  }

  virtual Decision* Next(Solver* const s) {
    if (pysolver_ == NULL) {
      pysolver_ = SWIG_NewPointerObj(s,
                                     SWIGTYPE_p_operations_research__Solver,
                                     SWIG_POINTER_EXCEPTION);
      pyarg_ = Py_BuildValue((char*)"(O)", pysolver_);
    }
    Decision* result = NULL;
    PyObject* pyresult = PyEval_CallObject(func_, pyarg_);
    if (pyresult) {
      if (SWIG_ConvertPtr(pyresult,
                          (void **) &result,
                          SWIGTYPE_p_operations_research__Decision,
                          SWIG_POINTER_EXCEPTION | 0) == -1) {
        LOG(INFO) << "Error in type from python Decision";
      }
      Py_DECREF(pyresult);
    } else {  // something went wrong, we fail.
      s->Fail();
    }
    return result;
  }

  virtual string DebugString() const {
    string result = "PyDecisionBuilder";
    if (str_func_) {
      PyObject* pyresult = PyEval_CallObject(str_func_, NULL);
      if (pyresult) {
        result = PyString_AsString(pyresult);
        Py_DECREF(pyresult);
      }
    }
    return result;
  }
 private:
  PyObject* pysolver_;
  PyObject* pyarg_;
  PyObject* pydb_;
  PyObject* func_;
  PyObject* str_func_;
};

class PyLNSNoValues : public BaseLNS {
 public:
  PyLNSNoValues(const std::vector<IntVar*>& vars, PyObject* op)
      : BaseLNS(vars.data(), vars.size()), op_(op) {
    Py_INCREF(op_);
    init_func_ = PyObject_GetAttrString(op_, "InitFragment");
    Py_XINCREF(init_func_);
    fragment_func_ = PyObject_GetAttrString(op_, "NextFragment");
    Py_XINCREF(fragment_func_);
  }
  virtual ~PyLNSNoValues() {
    Py_DECREF(op_);
    op_ = NULL;
    Py_XDECREF(init_func_);
    init_func_ = NULL;
    Py_XDECREF(fragment_func_);
    fragment_func_ = NULL;
  }

  virtual void InitFragments() {
    if (init_func_) {
      PyObject* pyresult = PyEval_CallObject(init_func_, NULL);
      Py_XDECREF(pyresult);
    }
  }

  virtual bool NextFragment(std::vector<int>* fragment) {
    PyObject* list = PyList_New(0);
    PyObject* args = Py_BuildValue((char*)"(O)", list);
    PyObject* pyresult = PyEval_CallObject(fragment_func_, args);
    Py_DECREF(args);
    const int size = PyList_Size(list);
    for (size_t i = 0; i < size; ++i) {
      const int val = PyInt_AsLong(PyList_GetItem(list, i));
      fragment->push_back(val);
    }
    Py_DECREF(list);
    bool result = false;
    if (pyresult) {
      result = PyInt_AsLong(pyresult);
      Py_DECREF(pyresult);
    }
    return result;
  }

  virtual string DebugString() const {
    return "PyLNSNoValues()";
  }
 private:
  PyObject* op_;
  PyObject* init_func_;
  PyObject* fragment_func_;
};

class PyLNS : public BaseLNS {
 public:
  PyLNS(const std::vector<IntVar*>& vars, PyObject* op)
      : BaseLNS(vars.data(), vars.size()), op_(op) {
    Py_INCREF(op_);
    init_func_ = PyObject_GetAttrString(op_, "InitFragment");
    Py_XINCREF(init_func_);
    fragment_func_ = PyObject_GetAttrString(op_, "NextFragment");
    Py_XINCREF(fragment_func_);
    base_lns_ = SWIG_NewPointerObj(this,
                                   SWIGTYPE_p_operations_research__BaseLNS,
                                   SWIG_POINTER_EXCEPTION);
    Py_INCREF(base_lns_);
  }
  virtual ~PyLNS() {
    Py_DECREF(op_);
    op_ = NULL;
    Py_XDECREF(init_func_);
    init_func_ = NULL;
    Py_XDECREF(fragment_func_);
    fragment_func_ = NULL;
    Py_DECREF(base_lns_);
    base_lns_ = NULL;
  }

  virtual void InitFragments() {
    if (init_func_) {
      PyObject* pyresult = PyEval_CallObject(init_func_, NULL);
      Py_XDECREF(pyresult);
    }
  }

  virtual bool NextFragment(std::vector<int>* fragment) {
    PyObject* list = PyList_New(0);
    PyObject* args = Py_BuildValue((char*)"(OO)", list, base_lns_);
    PyObject* pyresult = PyEval_CallObject(fragment_func_, args);
    Py_DECREF(args);
    const int size = PyList_Size(list);
    for (size_t i = 0; i < size; ++i) {
      const int val = PyInt_AsLong(PyList_GetItem(list, i));
      fragment->push_back(val);
    }
    Py_DECREF(list);
    bool result = false;
    if (pyresult) {
      result = PyInt_AsLong(pyresult);
      Py_DECREF(pyresult);
    }
    return result;
  }

  virtual string DebugString() const {
    return "PyLNS()";
  }
 private:
  PyObject* op_;
  PyObject* init_func_;
  PyObject* fragment_func_;
  PyObject* base_lns_;
};

}  // namespace operations_research
%}

namespace operations_research {
%pythoncode {
import gflags
FLAGS=gflags.FLAGS
gflags.DEFINE_boolean('cp_trace_propagation', False,
                      'trace all propagation events.')
gflags.DEFINE_boolean('cp_print_model', False,
                      'prints the model before solving it.')
gflags.DEFINE_boolean('cp_model_stats', False,
                      'displays model statistics before solving it.')
gflags.DEFINE_string('cp_export_file', '',
                     'exports model to file using CPModelProto.')
gflags.DEFINE_boolean('cp_no_solve', False,
                      'force failures at the beginning of a search.')
gflags.DEFINE_string('cp_profile_file', '',
                     'exports profiling overview to file.')
}
%pythoncode {

class PyDecisionBuilder(object):
  def NextWrapper(self, solver):
    result = None
    try:
      result = self.Next(solver)
    except Exception:
      return solver.FailDecision()
    return result
}
}  // namespace operations_research

// Rename rules on SolutionCollector.
%rename (Branches) operations_research::SolutionCollector::branches;
%rename (Failures) operations_research::SolutionCollector::failures;
%rename (ObjectiveValue) operations_research::SolutionCollector::objective_value;
%rename (Solution) operations_research::SolutionCollector::solution;
%rename (SolutionCount) operations_research::SolutionCollector::solution_count;
%rename (WallTime) operations_research::SolutionCollector::wall_time;

// Rename rule on OptimizeVar
%rename (Best) operations_research::OptimizeVar::best;

// Rename rule on SearchLimit
%rename (IsCrossed) operations_research::SearchLimit::crossed;

// Rename rules on Solver.
%rename (AcceptedNeighbors) operations_research::Solver::accepted_neighbors;
%rename (Add) operations_research::Solver::AddConstraint;
%rename (Branches) operations_research::Solver::branches;
%rename (DemonRuns) operations_research::Solver::demon_runs;
%rename (FailStamp) operations_research::Solver::fail_stamp;
%rename (Failures) operations_research::Solver::failures;
%rename (FilteredNeighbors) operations_research::Solver::filtered_neighbors;
%rename (Neighbors) operations_research::Solver::neighbors;
%rename (Solutions) operations_research::Solver::solutions;
%rename (Stamp) operations_research::Solver::stamp;
%rename (WallTime) operations_research::Solver::wall_time;

%rename("%(strip:[Make])s", %$isfunction) "";

namespace operations_research {
%typemap(in) IntExpr* const {
  operations_research::IntExpr* t;
  if (SWIG_ConvertPtr($input,
                      (void**)&t,
                      SWIGTYPE_p_operations_research__IntExpr,
                      SWIG_POINTER_EXCEPTION | 0 ) == -1) {
    operations_research::Constraint* c;
    if (SWIG_ConvertPtr($input,
                        (void**)&c,
                        SWIGTYPE_p_operations_research__Constraint,
                        SWIG_POINTER_EXCEPTION | 0 ) != -1) {
      operations_research::IntVar* const v = c->Var();
      if (v == NULL) {
        SWIG_fail;
      } else {
        $1 = v;
      }
    } else {
      SWIG_fail;
    }
  } else {
    $1 = t;
  }
}

%typecheck(SWIG_TYPECHECK_POINTER) IntExpr* const {
  operations_research::IntExpr* t;
  operations_research::Constraint* c;
  $1 = (SWIG_ConvertPtr($input,
                        (void**)&t,
                        SWIGTYPE_p_operations_research__IntExpr,
                        SWIG_POINTER_EXCEPTION | 0 ) != -1 ||
        SWIG_ConvertPtr($input,
                        (void**)&c,
                        SWIGTYPE_p_operations_research__Constraint,
                        SWIG_POINTER_EXCEPTION | 0 ) != -1);
  if ($1 == 0) {
    PyErr_Clear();
  }
}

%typemap(in) IntVar* const {
  operations_research::IntExpr* t;
  if (SWIG_ConvertPtr($input,
                      (void**)&t,
                      SWIGTYPE_p_operations_research__IntExpr,
                      SWIG_POINTER_EXCEPTION | 0 ) == -1) {
    operations_research::Constraint* c;
    if (SWIG_ConvertPtr($input,
                        (void**)&c,
                        SWIGTYPE_p_operations_research__Constraint,
                        SWIG_POINTER_EXCEPTION | 0 ) != -1) {
      if (c == NULL) {
        PyErr_SetString(PyExc_TypeError, "Invalid LanguageCode");
        SWIG_fail;
      }
      operations_research::IntVar* const v = c->Var();
      if (v == NULL) {
        SWIG_fail;
      } else {
        $1 = v;
      }
    } else {
      SWIG_fail;
    }
  } else {
    $1 = t->Var();
  }
}

%typecheck(SWIG_TYPECHECK_POINTER) IntVar* const {
  operations_research::IntExpr* t;
  operations_research::Constraint* c;
  $1 = (SWIG_ConvertPtr($input,
                        (void**)&t,
                        SWIGTYPE_p_operations_research__IntExpr,
                        SWIG_POINTER_EXCEPTION | 0 ) != -1 ||
        SWIG_ConvertPtr($input,
                        (void**)&c,
                        SWIGTYPE_p_operations_research__Constraint,
                        SWIG_POINTER_EXCEPTION | 0 ) != -1);

  if ($1 == 0) {
    PyErr_Clear();
  }
}

%typemap(in) const IntVar* const {
  operations_research::IntExpr* t;
  if (SWIG_ConvertPtr($input,
                      (void**)&t,
                      SWIGTYPE_p_operations_research__IntExpr,
                      SWIG_POINTER_EXCEPTION | 0 ) == -1) {
    SWIG_fail;
  }
  $1 = t->Var();
}

%typecheck(SWIG_TYPECHECK_POINTER) const IntVar* const {
  operations_research::IntExpr* t;
  $1 = SWIG_ConvertPtr($input,
                       (void**)&t,
                       SWIGTYPE_p_operations_research__IntExpr,
                       SWIG_POINTER_EXCEPTION | 0 ) != -1;
  if ($1 == 0) {
    PyErr_Clear();
  }
}

// Add conversion rules for std::vector<IntExpr*> and std::vector<IntVar*>. Please
// note that list of expressions will be converted to vectors of
// IntVar.
%typemap(in) const std::vector<IntVar*>& (std::vector<IntVar*> temp) {
  if (!PyTuple_Check($input) && !PyList_Check($input)) {
    PyErr_SetString(PyExc_TypeError, "Expecting a sequence");
    SWIG_fail;
  }
  bool is_tuple = PyTuple_Check($input);
  temp.resize(is_tuple ? PyTuple_Size($input) : PyList_Size($input));
  for (size_t i = 0; i < temp.size(); ++i) {
    PyObject *obj = (is_tuple ? PyTuple_GetItem($input, i) :
                     PyList_GetItem($input, i));
    operations_research::IntExpr* t;
    if ((SWIG_ConvertPtr(obj, (void**)&t,
                         SWIGTYPE_p_operations_research__IntExpr,
                         SWIG_POINTER_EXCEPTION | 0 )) == -1) {
      operations_research::Constraint* c;
      if (SWIG_ConvertPtr(obj,
                          (void**)&c,
                          SWIGTYPE_p_operations_research__Constraint,
                          SWIG_POINTER_EXCEPTION | 0 ) != -1) {
        if (c == NULL) {
          PyErr_SetString(PyExc_TypeError, "Invalid LanguageCode");
          SWIG_fail;
        }
        operations_research::IntVar* const v = c->Var();
        if (v == NULL) {
          SWIG_fail;
        } else {
          temp[i] = v;
        }
      } else {
        SWIG_fail;
      }
    } else {
      if (t == NULL) {
        PyErr_SetString(PyExc_TypeError, "Invalid LanguageCode");
        SWIG_fail;
      }
      temp[i] = t->Var();
    }
  }
  $1 = &temp;
}

%typecheck(SWIG_TYPECHECK_POINTER) const std::vector<IntVar*>& {
  if (!PyTuple_Check($input) && !PyList_Check($input)) {
    $1 = 0;
  } else {
    const bool is_tuple = PyTuple_Check($input);
    const int size = is_tuple ? PyTuple_Size($input) : PyList_Size($input);
    bool failed = false;
    for (size_t i = 0; i < size; ++i) {
      PyObject* const obj =
          is_tuple ? PyTuple_GetItem($input, i) : PyList_GetItem($input, i);
      operations_research::IntExpr* t;
      operations_research::Constraint* c;
      if ((SWIG_ConvertPtr(obj, (void**)&t,
                           SWIGTYPE_p_operations_research__IntExpr,
                           SWIG_POINTER_EXCEPTION | 0 )) == -1 &&
          SWIG_ConvertPtr(obj,
                          (void**)&c,
                          SWIGTYPE_p_operations_research__Constraint,
                          SWIG_POINTER_EXCEPTION | 0 ) == -1) {
        PyErr_Clear();
        failed = true;
        break;
      }
    }
    $1 = failed ? 0 : 1;
  }
}

// TODO(user): retest directors.
// Add conversion rules for std::vector<DecisionBuilder*>.
%typemap(in) const std::vector<DecisionBuilder*>&
    (std::vector<DecisionBuilder*> temp) {
  if (!PyTuple_Check($input) && !PyList_Check($input)) {
    PyErr_SetString(PyExc_TypeError, "Expecting a sequence");
    SWIG_fail;
  }
  bool is_tuple = PyTuple_Check($input);
  temp.resize(is_tuple ? PyTuple_Size($input) : PyList_Size($input));
  for (size_t i = 0; i < temp.size(); ++i) {
    PyObject *obj = (is_tuple ? PyTuple_GetItem($input, i) :
                     PyList_GetItem($input, i));
    operations_research::DecisionBuilder* t;
    if ((SWIG_ConvertPtr(obj, (void**)&t,
                         SWIGTYPE_p_operations_research__DecisionBuilder,
                         SWIG_POINTER_EXCEPTION | 0 )) == -1) {
      PyErr_Clear();
      t = new operations_research::CallPyDecisionBuilder(obj);
    }
    if (t == NULL) {
      PyErr_SetString(PyExc_TypeError, "Invalid LanguageCode");
      SWIG_fail;
    }
    temp[i] = t;
  }
  $1 = &temp;
}

%typecheck(SWIG_TYPECHECK_POINTER) const std::vector<DecisionBuilder*>& {
  if (!PyTuple_Check($input) && !PyList_Check($input)) {
    $1 = 0;
  } else {
    const bool is_tuple = PyTuple_Check($input);
    const int size = is_tuple ? PyTuple_Size($input) : PyList_Size($input);
    bool failed = false;
    for (size_t i = 0; i < size; ++i) {
      PyObject* const obj =
          is_tuple ? PyTuple_GetItem($input, i) : PyList_GetItem($input, i);
      operations_research::DecisionBuilder* t;
      if ((SWIG_ConvertPtr(obj, (void**)&t,
                           SWIGTYPE_p_operations_research__DecisionBuilder,
                           SWIG_POINTER_EXCEPTION | 0 )) == -1) {
        PyErr_Clear();
        PyObject* next_func = PyObject_GetAttrString(obj, "Next");
        failed = next_func == NULL;
        if (failed) {
          break;
        }
      }
    }
    $1 = failed ? 0 : 1;
  }
}

%define CONVERT_VECTOR(TYPE)
%typemap(in) const std::vector<TYPE*>&
    (std::vector<TYPE*> temp) {
  if (!PyTuple_Check($input) && !PyList_Check($input)) {
    PyErr_SetString(PyExc_TypeError, "Expecting a sequence");
    SWIG_fail;
  }
  bool is_tuple = PyTuple_Check($input);
  temp.resize(is_tuple ? PyTuple_Size($input) : PyList_Size($input));
  for (size_t i = 0; i < temp.size(); ++i) {
    PyObject *obj = (is_tuple ? PyTuple_GetItem($input, i) :
                     PyList_GetItem($input, i));
    operations_research::TYPE* t;
    if ((SWIG_ConvertPtr(obj, (void**)&t,
                         SWIGTYPE_p_operations_research__##TYPE,
                         SWIG_POINTER_EXCEPTION | 0 )) == -1) {
      SWIG_fail;
    }
    if (t == NULL) {
      PyErr_SetString(PyExc_TypeError, "Invalid LanguageCode");
      SWIG_fail;
    }
    temp[i] = t;
  }
  $1 = &temp;
}

%typecheck(SWIG_TYPECHECK_POINTER) const std::vector<TYPE*>& {
  if (!PyTuple_Check($input) && !PyList_Check($input)) {
    $1 = 0;
  } else {
    const bool is_tuple = PyTuple_Check($input);
    const int size = is_tuple ? PyTuple_Size($input) : PyList_Size($input);
    bool failed = false;
    for (size_t i = 0; i < size; ++i) {
      PyObject* const obj =
          is_tuple ? PyTuple_GetItem($input, i) : PyList_GetItem($input, i);
      operations_research::TYPE* t;
      if ((SWIG_ConvertPtr(obj, (void**)&t,
                           SWIGTYPE_p_operations_research__##TYPE,
                           SWIG_POINTER_EXCEPTION | 0 )) == -1) {
        PyErr_Clear();
        failed = true;
        break;
      }
    }
    $1 = failed ? 0 : 1;
  }
}
%enddef

CONVERT_VECTOR(SearchMonitor);
CONVERT_VECTOR(IntervalVar);
CONVERT_VECTOR(SequenceVar);
CONVERT_VECTOR(LocalSearchOperator);
CONVERT_VECTOR(LocalSearchFilter);

%typemap(in) DecisionBuilder* const {
  operations_research::DecisionBuilder* tmp;
  if (SWIG_ConvertPtr($input,
                      (void **) &tmp,
                      SWIGTYPE_p_operations_research__DecisionBuilder,
                      SWIG_POINTER_EXCEPTION | 0) == -1) {
    PyErr_Clear();
    $1 = new operations_research::CallPyDecisionBuilder($input);
  } else {
    $1 = tmp;
  }
}

%typecheck(SWIG_TYPECHECK_POINTER) DecisionBuilder* const {
  operations_research::DecisionBuilder* tmp;
  if (SWIG_ConvertPtr($input,
                      (void **) &tmp,
                      SWIGTYPE_p_operations_research__DecisionBuilder,
                      SWIG_POINTER_EXCEPTION | 0) == -1) {
    PyErr_Clear();
    PyObject* next_func = PyObject_GetAttrString($input, "Next");
    $1 =  next_func != NULL;
  } else {
    $1 = 1;
  }
}

// Add display methods on BaseObject and remove DebugString method.
%ignore BaseObject::DebugString;
%extend BaseObject {
  string __str__() {
    return self->DebugString();
  }
  string __repr__() {
    return self->DebugString();
  }
}

%extend IntervalVar {
  string __repr__() {
    return self->DebugString();
  }
  Constraint* EndsAfterEnd(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::ENDS_AFTER_END, other);
  }
  Constraint* EndsAfterStart(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::ENDS_AFTER_START, other);
  }
  Constraint* EndsAtEnd(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::ENDS_AT_END, other);
  }
  Constraint* EndsAtStart(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::ENDS_AT_START, other);
  }
  Constraint* StartsAfterEnd(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::STARTS_AFTER_END, other);
  }
  Constraint* StartsAfterStart(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STARTS_AFTER_START,
                                                   other);
  }
  Constraint* StartsAtEnd(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::STARTS_AT_END, other);
  }
  Constraint* StartsAtStart(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STARTS_AT_START,
                                                   other);
  }
  Constraint* StaysInSync(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STAYS_IN_SYNC,
                                                   other);
  }
  Constraint* EndsAfter(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::ENDS_AFTER,
                                                   date);
  }
  Constraint* EndsAt(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::ENDS_AT,
                                                   date);
  }
  Constraint* EndsBefore(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::ENDS_BEFORE,
                                                   date);
  }
  Constraint* StartsAfter(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STARTS_AFTER,
                                                   date);
  }
  Constraint* StartsAt(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STARTS_AT,
                                                   date);
  }
  Constraint* StartsBefore(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STARTS_BEFORE,
                                                   date);
  }
  Constraint* CrossesDate(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::CROSS_DATE,
                                                   date);
  }
  Constraint* AvoidsDate(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::AVOID_DATE,
                                                   date);
  }
}

%extend SequenceVar {
  string __repr__() {
    return self->DebugString();
  }
}

%extend IntVar {
  string __repr__() {
    return self->DebugString();
  }
}

%extend IntExpr {
  string __repr__() {
    return self->DebugString();
  }
}

%extend Constraint {
  string __repr__() {
    return self->DebugString();
  }
}

%extend SearchMonitor {
  string __repr__() {
    return self->DebugString();
  }
}

%extend DecisionBuilder {
  string __repr__() {
    return self->DebugString();
  }
}

%extend Decision {
  string __repr__() {
    return self->DebugString();
  }
}

// Add display methods on Solver and remove DebugString method.
%ignore Solver::DebugString;

// Indentation is critical here as the code is copied verbatim in the
// python code.
%feature("pythonappend") Solver::Solver %{
        Solver.SetPythonFlags(FLAGS.cp_trace_propagation,
                              FLAGS.cp_print_model,
                              FLAGS.cp_model_stats,
                              FLAGS.cp_export_file,
                              FLAGS.cp_no_solve,
                              FLAGS.cp_profile_file)
%}


%extend Solver {
static void SetPythonFlags(bool trace_propagation,
                             bool print_model,
                             bool model_stats,
                             const string& export_file,
                             bool no_solve,
                             const string& profile_file) {
    FLAGS_cp_trace_propagation = trace_propagation;
    FLAGS_cp_print_model = print_model;
    FLAGS_cp_model_stats = model_stats;
    FLAGS_cp_export_file = export_file;
    FLAGS_cp_no_solve = no_solve;
    FLAGS_cp_profile_file = profile_file;
  }

  Constraint* TreeNoCycle(const std::vector<IntVar*>& nexts,
                          const std::vector<IntVar*>& active,
                          ResultCallback1<bool, int64>* callback = NULL) {
    return self->MakeNoCycle(nexts, active, callback, false);
  }

  SearchMonitor* SearchLogWithCallback(int period,
                                       ResultCallback<string>* callback) {
    return self->MakeSearchLog(period, callback);
  }

  IntExpr* ElementFunction(ResultCallback1<int64, int64>* values,
                           IntVar* const index) {
    return self->MakeElement(values, index);
  }
  string __str__() {
    return self->DebugString();
  }

  LocalSearchOperator* LNSOperator(const std::vector<IntVar*>& vars,
                                   PyObject* lns) {
    return self->RevAlloc(new operations_research::PyLNS(vars, lns));
  }

  LocalSearchOperator* LNSNoValuesOperator(const std::vector<IntVar*>& vars,
                                           PyObject* lns) {
    return self->RevAlloc(new operations_research::PyLNSNoValues(vars, lns));
  }

  DecisionBuilder* VarEvalValStrPhase(
      const std::vector<IntVar*>& vars,
      ResultCallback1<int64, int64>* var_evaluator,
      operations_research::Solver::IntValueStrategy val_str) {
    return self->MakePhase(vars, var_evaluator, val_str);
  }

  DecisionBuilder* VarStrValEvalPhase(
      const std::vector<IntVar*>& vars,
      operations_research::Solver::IntVarStrategy var_str,
      ResultCallback2<int64, int64, int64>* val_eval) {
    return self->MakePhase(vars, var_str, val_eval);
  }

  DecisionBuilder* VarEvalValEvalPhase(
      const std::vector<IntVar*>& vars,
      ResultCallback1<int64, int64>* var_eval,
      ResultCallback2<int64, int64, int64>* val_eval) {
    return self->MakePhase(vars, var_eval, val_eval);
  }

  DecisionBuilder* VarStrValEvalTieBreakPhase(
      const std::vector<IntVar*>& vars,
      operations_research::Solver::IntVarStrategy var_str,
      ResultCallback2<int64, int64, int64>* val_eval,
      ResultCallback1<int64, int64>* tie_breaker) {
    return self->MakePhase(vars, var_str, val_eval, tie_breaker);
  }

  DecisionBuilder* VarEvalValEvalTieBreakPhase(
      const std::vector<IntVar*>& vars,
      ResultCallback1<int64, int64>* var_eval,
      ResultCallback2<int64, int64, int64>* val_eval,
      ResultCallback1<int64, int64>* tie_breaker) {
    return self->MakePhase(vars, var_eval, val_eval, tie_breaker);
  }

  DecisionBuilder* EvalEvalStrPhase(
      const std::vector<IntVar*>& vars,
      ResultCallback2<int64, int64, int64>* evaluator,
      operations_research::Solver::EvaluatorStrategy str) {
    return self->MakePhase(vars, evaluator, str);
  }

  DecisionBuilder* EvalEvalStrTieBreakPhase(
      const std::vector<IntVar*>& vars,
      ResultCallback2<int64, int64, int64>* evaluator,
      ResultCallback1<int64, int64>* tie_breaker,
      operations_research::Solver::EvaluatorStrategy str) {
    return self->MakePhase(vars, evaluator, tie_breaker, str);
  }

  SearchMonitor* GuidedLocalSearch(
      bool maximize,
      IntVar* const objective,
      ResultCallback2<int64, int64, int64>* objective_function,
      int64 step,
      const std::vector<IntVar*>& vars,
      double penalty_factor) {
    return self->MakeGuidedLocalSearch(maximize,
                                       objective,
                                       objective_function,
                                       step,
                                       vars,
                                       penalty_factor);
  }

  LocalSearchFilter* LocalSearchObjectiveFilter(
      const std::vector<IntVar*>& vars,
      ResultCallback2<int64, int64, int64>* values,
      const IntVar* const objective,
      Solver::LocalSearchFilterBound filter_enum,
      Solver::LocalSearchOperation op_enum) {
    return self->MakeLocalSearchObjectiveFilter(vars,
                                                values,
                                                objective,
                                                filter_enum,
                                                op_enum);
  }
}

// Ignore wrapping of some solver methods.
%ignore Solver::MakeIntVarArray;
%ignore Solver::MakeBoolVarArray;
%ignore Solver::MakeSum(IntExpr* const left, IntExpr* const right);
%ignore Solver::MakeSum(IntExpr* const expr, int64 value);
%ignore Solver::MakeSum(IntVar* const * vars, int size);
%ignore Solver::MakeDifference;
%ignore Solver::MakeOpposite;
%ignore Solver::MakeProd;
%ignore Solver::MakeSquare;
%ignore Solver::MakeElement(ResultCallback1<int64, int64>* values,
                            IntVar* const index);
%ignore Solver::MakeMin(IntExpr* const expr, int val);
%ignore Solver::MakeMax(IntExpr* const expr, int val);
%ignore Solver::MakeEquality;
%ignore Solver::MakeNonEquality;
%ignore Solver::MakeGreaterOrEqual;
%ignore Solver::MakeGreater;
%ignore Solver::MakeLessOrEqual;
%ignore Solver::MakeLess;
%ignore Solver::MakeConstraintInitialPropagateCallback;
%ignore Solver::MakeDelayedConstraintInitialPropagateCallback;
%ignore Solver::MakePhase(IntVar* const v0, PhaseStrategy str);
%ignore Solver::MakePhase(IntVar* const v0,
                          IntVar* const v1,
                          PhaseStrategy str);
%ignore Solver::MakePhase(IntVar* const v0,
                          IntVar* const v1,
                          IntVar* const v2,
                          PhaseStrategy str);
%ignore Solver::MakePhase(IntVar* const v0,
                          IntVar* const v1,
                          IntVar* const v3,
                          IntVar* const v4,
                          PhaseStrategy str);
%ignore Solver::Compose(DecisionBuilder* const db1,
                        DecisionBuilder* const db2);
%ignore Solver::Compose(DecisionBuilder* const db1,
                        DecisionBuilder* const db2,
                        DecisionBuilder* const db3);
%ignore Solver::Compose(DecisionBuilder* const db1,
                        DecisionBuilder* const db2,
                        DecisionBuilder* const db3,
                        DecisionBuilder* const db4);

// Add arithmetic operators to integer expressions.
%extend IntExpr {
  IntExpr* __add__(IntExpr* other) {
    return self->solver()->MakeSum(self, other);
  }
  IntExpr* __add__(Constraint* other) {
    return self->solver()->MakeSum(self, other->Var());
  }
  IntExpr* __add__(int64 v) {
    return self->solver()->MakeSum(self, v);
  }
  IntExpr* __radd__(int64 v) {
    return self->solver()->MakeSum(self, v);
  }
  IntExpr* __sub__(IntExpr* other) {
    return self->solver()->MakeDifference(self, other);
  }
  IntExpr* __sub__(Constraint* other) {
    return self->solver()->MakeDifference(self, other->Var());
  }
  IntExpr* __sub__(int64 v) {
    return self->solver()->MakeSum(self, -v);
  }
  IntExpr* __rsub__(int64 v) {
    return self->solver()->MakeDifference(v, self);
  }
  IntExpr* __mul__(IntExpr* other) {
    return self->solver()->MakeProd(self, other);
  }
  IntExpr* __mul__(Constraint* other) {
    return self->solver()->MakeProd(self, other->Var());
  }
  IntExpr* __mul__(int64 v) {
    return self->solver()->MakeProd(self, v);
  }
  IntExpr* __rmul__(int64 v) {
    return self->solver()->MakeProd(self, v);
  }
  IntExpr* __floordiv__(int64 v) {
    return self->solver()->MakeDiv(self, v);
  }

  IntExpr* __neg__() {
    return self->solver()->MakeOpposite(self);
  }
  IntExpr* __abs__() {
    return self->solver()->MakeAbs(self);
  }
  IntExpr* Square() {
    return self->solver()->MakeSquare(self);
  }

  Constraint* __eq__(int64 v) {
    return self->solver()->MakeEquality(self, v);
  }
  Constraint* __ne__(int64 v) {
    return self->solver()->MakeNonEquality(self->Var(), v);
  }
  Constraint* __ge__(int64 v) {
    return self->solver()->MakeGreaterOrEqual(self, v);
  }
  Constraint* __gt__(int64 v) {
    return self->solver()->MakeGreater(self, v);
  }
  Constraint* __le__(int64 v) {
    return self->solver()->MakeLessOrEqual(self, v);
  }
  Constraint* __lt__(int64 v) {
    return self->solver()->MakeLess(self, v);
  }
  Constraint* __eq__(IntExpr* other) {
    return self->solver()->MakeEquality(self->Var(), other->Var());
  }
  Constraint* __ne__(IntExpr* other) {
    return self->solver()->MakeNonEquality(self->Var(), other->Var());
  }
  Constraint* __ge__(IntExpr* other) {
    return self->solver()->MakeGreaterOrEqual(self->Var(), other->Var());
  }
  Constraint* __gt__(IntExpr* other) {
    return self->solver()->MakeGreater(self->Var(), other->Var());
  }
  Constraint* __le__(IntExpr* other) {
    return self->solver()->MakeLessOrEqual(self->Var(), other->Var());
  }
  Constraint* __lt__(IntExpr* other) {
    return self->solver()->MakeLess(self->Var(), other->Var());
  }
  Constraint* __eq__(Constraint* other) {
    return self->solver()->MakeEquality(self->Var(), other->Var());
  }
  Constraint* __ne__(Constraint* other) {
    return self->solver()->MakeNonEquality(self->Var(), other->Var());
  }
  Constraint* __ge__(Constraint* other) {
    return self->solver()->MakeGreaterOrEqual(self->Var(), other->Var());
  }
  Constraint* __gt__(Constraint* other) {
    return self->solver()->MakeGreater(self->Var(), other->Var());
  }
  Constraint* __le__(Constraint* other) {
    return self->solver()->MakeLessOrEqual(self->Var(), other->Var());
  }
  Constraint* __lt__(Constraint* other) {
    return self->solver()->MakeLess(self->Var(), other->Var());
  }
  Constraint* MapTo(const std::vector<IntVar*>& vars) {
    return self->solver()->MakeMapDomain(self->Var(), vars);
  }
  IntExpr* IndexOf(const std::vector<int64>& vars) {
    return self->solver()->MakeElement(vars, self->Var());
  }
  IntExpr* IndexOf(const std::vector<IntVar*>& vars) {
    return self->solver()->MakeElement(vars, self->Var());
  }
}

// Add arithmetic operators to integer expressions.
%extend Constraint {
  IntExpr* __add__(IntExpr* other) {
    return self->solver()->MakeSum(self->Var(), other);
  }
  IntExpr* __add__(Constraint* other) {
    return self->solver()->MakeSum(self->Var(), other->Var());
  }
  IntExpr* __add__(int64 v) {
    return self->solver()->MakeSum(self->Var(), v);
  }
  IntExpr* __radd__(int64 v) {
    return self->solver()->MakeSum(self->Var(), v);
  }
  IntExpr* __sub__(IntExpr* other) {
    return self->solver()->MakeDifference(self->Var(), other);
  }
  IntExpr* __sub__(Constraint* other) {
    return self->solver()->MakeDifference(self->Var(), other->Var());
  }
  IntExpr* __sub__(int64 v) {
    return self->solver()->MakeSum(self->Var(), -v);
  }
  IntExpr* __rsub__(int64 v) {
    return self->solver()->MakeDifference(v, self->Var());
  }
  IntExpr* __mul__(IntExpr* other) {
    return self->solver()->MakeProd(self->Var(), other);
  }
  IntExpr* __mul__(Constraint* other) {
    return self->solver()->MakeProd(self->Var(), other->Var());
  }
  IntExpr* __mul__(int64 v) {
    return self->solver()->MakeProd(self->Var(), v);
  }
  IntExpr* __rmul__(int64 v) {
    return self->solver()->MakeProd(self->Var(), v);
  }
  IntExpr* __floordiv__(int64 v) {
    return self->solver()->MakeDiv(self->Var(), v);
  }

  IntExpr* __neg__() {
    return self->solver()->MakeOpposite(self->Var());
  }
  IntExpr* __abs__() {
    return self->solver()->MakeAbs(self->Var());
  }
  IntExpr* Square() {
    return self->solver()->MakeSquare(self->Var());
  }

  Constraint* __eq__(int64 v) {
    return self->solver()->MakeEquality(self->Var(), v);
  }
  Constraint* __ne__(int64 v) {
    return self->solver()->MakeNonEquality(self->Var(), v);
  }
  Constraint* __ge__(int64 v) {
    return self->solver()->MakeGreaterOrEqual(self->Var(), v);
  }
  Constraint* __gt__(int64 v) {
    return self->solver()->MakeGreater(self->Var(), v);
  }
  Constraint* __le__(int64 v) {
    return self->solver()->MakeLessOrEqual(self->Var(), v);
  }
  Constraint* __lt__(int64 v) {
    return self->solver()->MakeLess(self->Var(), v);
  }
  Constraint* __eq__(IntExpr* other) {
    return self->solver()->MakeEquality(self->Var(), other->Var());
  }
  Constraint* __ne__(IntExpr* other) {
    return self->solver()->MakeNonEquality(self->Var(), other->Var());
  }
  Constraint* __ge__(IntExpr* other) {
    return self->solver()->MakeGreaterOrEqual(self->Var(), other->Var());
  }
  Constraint* __gt__(IntExpr* other) {
    return self->solver()->MakeGreater(self->Var(), other->Var());
  }
  Constraint* __le__(IntExpr* other) {
    return self->solver()->MakeLessOrEqual(self->Var(), other->Var());
  }
  Constraint* __lt__(IntExpr* other) {
    return self->solver()->MakeLess(self->Var(), other->Var());
  }
  Constraint* __eq__(Constraint* other) {
    return self->solver()->MakeEquality(self->Var(), other->Var());
  }
  Constraint* __ne__(Constraint* other) {
    return self->solver()->MakeNonEquality(self->Var(), other->Var());
  }
  Constraint* __ge__(Constraint* other) {
    return self->solver()->MakeGreaterOrEqual(self->Var(), other->Var());
  }
  Constraint* __gt__(Constraint* other) {
    return self->solver()->MakeGreater(self->Var(), other->Var());
  }
  Constraint* __le__(Constraint* other) {
    return self->solver()->MakeLessOrEqual(self->Var(), other->Var());
  }
  Constraint* __lt__(Constraint* other) {
    return self->solver()->MakeLess(self->Var(), other->Var());
  }
  Constraint* MapTo(const std::vector<IntVar*>& vars) {
    return self->solver()->MakeMapDomain(self->Var(), vars);
  }
  IntExpr* IndexOf(const std::vector<int64>& vars) {
    return self->solver()->MakeElement(vars, self->Var());
  }
  IntExpr* IndexOf(const std::vector<IntVar*>& vars) {
    return self->solver()->MakeElement(vars, self->Var());
  }
}

%extend BaseLNS {
  int64 __getitem__(int index) {
    return self->Value(index);
  }

  int __len__() {
    return self->Size();
  }
}

// Protect from failure
#define PREPROTECT\
  FailureProtect protect;\
  Closure* const intercept = \
      NewCallback<>(&protect, &FailureProtect::JumpBack);\
  solver->set_fail_intercept(intercept);\
  if (setjmp(protect.exception_buffer) == 0) {

#define POSTPROTECT\
    solver->clear_fail_intercept();\
    delete intercept;\
  } else {\
    solver->clear_fail_intercept();\
    PyErr_SetString(PyExc_IndexError, "fail");\
    SWIG_fail;\
  }

%exception IntExpr::SetValue(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntExpr::SetMin(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntExpr::SetMax(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntExpr::SetRange(int64 mi, int64 ma) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntVar::RemoveValue(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception Solver::AddConstraint(Constraint* const ct) {
  operations_research::Solver* const solver = arg1;
  PREPROTECT
    $action
  POSTPROTECT
}
%exception Solver::Fail() {
  operations_research::Solver* const solver = arg1;
  PREPROTECT
    $action
  POSTPROTECT
}
}  // namespace operations_research
#endif  // SWIGPYTHON

#if defined(SWIGJAVA)
%module(directors="1") operations_research;
%feature("director") DecisionBuilder;
%feature("director") Decision;
%feature("director") SearchMonitor;
%feature("director") Action;
%feature("director") LocalSearchOperator;
%feature("director") PathOperator;
%feature("director") BaseLNS;
%feature("director") IntVarLocalSearchOperator;
%feature("director") IntVarLocalSearchFilter;

%include "std_vector.i"

%template(IntVector) std::vector<int>;

%{
#include <setjmp.h>

#include "constraint_solver/constraint_solver.h"
#include "constraint_solver/constraint_solveri.h"

namespace operations_research {
class LocalSearchPhaseParameters {
 public:
  LocalSearchPhaseParameters() {}
  ~LocalSearchPhaseParameters() {}
};
}  // namespace operations_research

struct FailureProtect {
  jmp_buf exception_buffer;
  void JumpBack() {
    longjmp(exception_buffer, 1);
  }
};
%}

%ignore operations_research::Solver::MakeIntVarArray;
%ignore operations_research::Solver::MakeBoolVarArray;
%ignore operations_research::Solver::MakeFixedDurationIntervalVarArray;
%ignore operations_research::IntVarLocalSearchFilter::FindIndex;

%rename (nextWrap) operations_research::DecisionBuilder::Next;
%rename (toString) *::DebugString;
%rename (tryDecisions) operations_research::Solver::Try;

%rename("%(lowercamelcase)s", %$isfunction) "";

namespace operations_research {
%define CONVERT_VECTOR(type)
%typemap(jni) const std::vector<type*>& "jobjectArray"
%typemap(jtype) const std::vector<type*>& "type[]"
%typemap(jstype) const std::vector<type*>& "type[]"
%typemap(javain) const std::vector<type*>& "$javainput"
%typemap(in) const std::vector<type*>& (std::vector<type*> result) {
  jclass object_class =
    jenv->FindClass("com/google/ortools/"
                    "constraintsolver/type");
  if (NULL == object_class)
    return $null;
  jmethodID method_id =
      jenv->GetStaticMethodID(object_class,
                              "getCPtr",
                              "(Lcom/google/ortools/"
                              "constraintsolver/type;)J");
  assert(method_id != NULL);
  for (int i = 0; i < jenv->GetArrayLength($input); i++) {
    jobject elem = jenv->GetObjectArrayElement($input, i);
    jlong ptr_value = jenv->CallStaticLongMethod(object_class, method_id, elem);
    result.push_back(reinterpret_cast<operations_research::type*>(ptr_value));
  }
  $1 = &result;
}
%enddef
CONVERT_VECTOR(IntVar);
CONVERT_VECTOR(SearchMonitor);
CONVERT_VECTOR(DecisionBuilder);
CONVERT_VECTOR(IntervalVar);
CONVERT_VECTOR(SequenceVar);
CONVERT_VECTOR(LocalSearchOperator);
CONVERT_VECTOR(LocalSearchFilter);

%typemap(javacode) Solver %{
  public IntVar[] makeIntVarArray(int count, long min, long max) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = makeIntVar(min, max);
    }
    return array;
  }

  public IntVar[] makeIntVarArray(int count, long min, long max, String name) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      String var_name = name + i;
      array[i] = makeIntVar(min, max, var_name);
    }
    return array;
  }

  public IntVar[] makeBoolVarArray(int count) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = makeBoolVar();
    }
    return array;
  }

  public IntVar[] makeBoolVarArray(int count, String name) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      String var_name = name + i;
      array[i] = makeBoolVar(var_name);
    }
    return array;
  }

  public IntervalVar[] makeFixedDurationIntervalVarArray(int count,
                                                         long start_min,
                                                         long start_max,
                                                         long duration,
                                                         boolean optional) {
    IntervalVar[] array = new IntervalVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = makeFixedDurationIntervalVar(start_min,
                                              start_max,
                                              duration,
                                              optional,
                                              "");
    }
    return array;
  }

  public IntervalVar[] makeFixedDurationIntervalVarArray(int count,
                                                         long start_min,
                                                         long start_max,
                                                         long duration,
                                                         boolean optional,
                                                         String name) {
    IntervalVar[] array = new IntervalVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = makeFixedDurationIntervalVar(start_min,
                                              start_max,
                                              duration,
                                              optional,
                                              name + i);
    }
    return array;
  }

%}

%extend IntVarLocalSearchFilter {
  int Index(IntVar* const var) {
    int64 index = -1;
    self->FindIndex(var, &index);
    return index;
  }
}

// Protect from failure
#define PREPROTECT\
  FailureProtect protect;\
  Closure* const intercept = \
      NewCallback<>(&protect, &FailureProtect::JumpBack);\
  solver->set_fail_intercept(intercept);\
  if (setjmp(protect.exception_buffer) == 0) {

#define POSTPROTECT\
    solver->clear_fail_intercept();\
    delete intercept;\
  } else {\
    solver->clear_fail_intercept();\
    jclass fail_class = jenv->FindClass(\
        "com/google/ortools/constraintsolver/"\
        "FailException");\
    jenv->ThrowNew(fail_class, "fail");\
    return $null;\
  }

%exception IntExpr::SetValue(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntExpr::SetMin(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntExpr::SetMax(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntExpr::SetRange(int64 mi, int64 ma) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntVar::RemoveValue(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception Solver::AddConstraint(Constraint* const ct) {
  operations_research::Solver* const solver = arg1;
  PREPROTECT
    $action
  POSTPROTECT
}
%exception Solver::Fail() {
  operations_research::Solver* const solver = arg1;
  PREPROTECT
    $action
  POSTPROTECT
}
}  // namespace operations_research

namespace operations_research {
class LocalSearchPhaseParameters {
 public:
  LocalSearchPhaseParameters() {}
  ~LocalSearchPhaseParameters() {}
};
}  // namespace operations_research

#endif  // SWIGJAVA

#if defined(SWIGCSHARP)

%module(directors="1") operations_research;
%feature("director") DecisionBuilder;
%feature("director") Decision;
%feature("director") SearchMonitor;
%feature("director") Action;
%feature("director") BaseLNS;
%feature("director") IntVarLocalSearchOperator;
%feature("director") IntVarLocalSearchFilter;;

%include "std_vector.i"

%template(IntVector) std::vector<int>;

%{
#include <setjmp.h>

#include "constraint_solver/constraint_solver.h"
#include "constraint_solver/constraint_solveri.h"

namespace operations_research {
class LocalSearchPhaseParameters {
 public:
  LocalSearchPhaseParameters() {}
  ~LocalSearchPhaseParameters() {}
};
}  // namespace operations_research



struct FailureProtect {
  jmp_buf exception_buffer;
  void JumpBack() {
    longjmp(exception_buffer, 1);
  }
};
%}

%ignore operations_research::Solver::MakeIntVarArray;
%ignore operations_research::Solver::MakeBoolVarArray;
%ignore operations_research::Solver::MakeFixedDurationIntervalVarArray;
%ignore operations_research::IntVarLocalSearchFilter::FindIndex;

// Generic rename rule.
%rename("%(camelcase)s", %$isfunction) "";

// Rename rule on DecisionBuilder;
%rename (NextWrap) operations_research::DecisionBuilder::Next;

// Rename rule on SearchLimit
%rename (IsCrossed) operations_research::SearchLimit::crossed;

// Rename rules on Solver.
%rename (Add) operations_research::Solver::AddConstraint;

// Rename rule on DisjunctiveConstraint.
%rename (SequenceVar) operations_research::DisjunctiveConstraint::MakeSequenceVar;

// Generic rename rules.
%rename (ToString) *::DebugString;

// Keep the .solver() API.
%rename (solver) *::solver;

%typemap(csinterfaces_derived) operations_research::Constraint "IConstraintWithStatus";
%typemap(cscode) operations_research::Constraint %{
  public static implicit operator IntVar(Constraint eq)
  {
    return eq.Var();
  }

  public static implicit operator IntExpr(Constraint eq)
  {
    return eq.Var();
  }
  public static IntExpr operator+(Constraint a, Constraint b) {
    return a.solver().MakeSum(a.Var(), b.Var());
  }
  public static IntExpr operator+(Constraint a, long v) {
    return a.solver().MakeSum(a.Var(), v);
  }
  public static IntExpr operator+(long v, Constraint a) {
    return a.solver().MakeSum(a.Var(), v);
  }
  public static IntExpr operator-(Constraint a, Constraint b) {
    return a.solver().MakeDifference(a.Var(), b.Var());
  }
  public static IntExpr operator-(Constraint a, long v) {
    return a.solver().MakeSum(a.Var(), -v);
  }
  public static IntExpr operator-(long v, Constraint a) {
    return a.solver().MakeDifference(v, a.Var());
  }
  public static IntExpr operator*(Constraint a, Constraint b) {
    return a.solver().MakeProd(a.Var(), b.Var());
  }
  public static IntExpr operator*(Constraint a, long v) {
    return a.solver().MakeProd(a.Var(), v);
  }
  public static IntExpr operator*(long v, Constraint a) {
    return a.solver().MakeProd(a.Var(), v);
  }
  public static IntExpr operator/(Constraint a, long v) {
    return a.solver().MakeDiv(a.Var(), v);
  }
  public static IntExpr operator-(Constraint a) {
    return a.solver().MakeOpposite(a.Var());
  }
  public IntExpr Abs() {
    return this.solver().MakeAbs(this.Var());
  }
  public IntExpr Square() {
    return this.solver().MakeSquare(this.Var());
  }
  public static WrappedConstraint operator ==(Constraint a, long v) {
    return new WrappedConstraint(a.solver().MakeEquality(a.Var(), v));
  }
  public static WrappedConstraint operator ==(long v, Constraint a) {
    return new WrappedConstraint(a.solver().MakeEquality(a.Var(), v));
  }
  public static WrappedConstraint operator !=(Constraint a, long v) {
    return new WrappedConstraint(a.solver().MakeNonEquality(a.Var(), v));
  }
  public static WrappedConstraint operator !=(long v, Constraint a) {
    return new WrappedConstraint(a.solver().MakeNonEquality(a.Var(), v));
  }
  public static WrappedConstraint operator >=(Constraint a, long v) {
    return new WrappedConstraint(a.solver().MakeGreaterOrEqual(a.Var(), v));
  }
  public static WrappedConstraint operator >=(long v, Constraint a) {
    return new WrappedConstraint(a.solver().MakeLessOrEqual(a.Var(), v));
  }
  public static WrappedConstraint operator >(Constraint a, long v) {
    return new WrappedConstraint(a.solver().MakeGreater(a.Var(), v));
  }
  public static WrappedConstraint operator >(long v, Constraint a) {
    return new WrappedConstraint(a.solver().MakeLess(a.Var(), v));
  }
  public static WrappedConstraint operator <=(Constraint a, long v) {
    return new WrappedConstraint(a.solver().MakeLessOrEqual(a.Var(), v));
  }
  public static WrappedConstraint operator <=(long v, Constraint a) {
    return new WrappedConstraint(a.solver().MakeGreaterOrEqual(a.Var(), v));
  }
  public static WrappedConstraint operator <(Constraint a, long v) {
    return new WrappedConstraint(a.solver().MakeLess(a.Var(), v));
  }
  public static WrappedConstraint operator <(long v, Constraint a) {
    return new WrappedConstraint(a.solver().MakeGreater(a.Var(), v));
  }
  public static WrappedConstraint operator >=(Constraint a, Constraint b) {
    return new WrappedConstraint(a.solver().MakeGreaterOrEqual(a.Var(), b.Var()));
  }
  public static WrappedConstraint operator >(Constraint a, Constraint b) {
    return new WrappedConstraint(a.solver().MakeGreater(a.Var(), b.Var()));
  }
  public static WrappedConstraint operator <=(Constraint a, Constraint b) {
    return new WrappedConstraint(a.solver().MakeLessOrEqual(a.Var(), b.Var()));
  }
  public static WrappedConstraint operator <(Constraint a, Constraint b) {
    return new WrappedConstraint(a.solver().MakeLess(a.Var(), b.Var()));
  }
  public static ConstraintEquality operator ==(Constraint a, Constraint b) {
    return new ConstraintEquality(a, b, true);
  }
  public static ConstraintEquality operator !=(Constraint a, Constraint b) {
    return new ConstraintEquality(a, b, false);
  }
%}


// Add arithmetic operators to integer expressions.
%typemap(cscode) operations_research::IntExpr %{
  public static IntExpr operator+(IntExpr a, IntExpr b) {
    return a.solver().MakeSum(a, b);
  }
  public static IntExpr operator+(IntExpr a, long v) {
    return a.solver().MakeSum(a, v);
  }
  public static IntExpr operator+(long v, IntExpr a) {
    return a.solver().MakeSum(a, v);
  }
  public static IntExpr operator-(IntExpr a, IntExpr b) {
    return a.solver().MakeDifference(a, b);
  }
  public static IntExpr operator-(IntExpr a, long v) {
    return a.solver().MakeSum(a, -v);
  }
  public static IntExpr operator-(long v, IntExpr a) {
    return a.solver().MakeDifference(v, a);
  }
  public static IntExpr operator*(IntExpr a, IntExpr b) {
    return a.solver().MakeProd(a, b);
  }
  public static IntExpr operator*(IntExpr a, long v) {
    return a.solver().MakeProd(a, v);
  }
  public static IntExpr operator*(long v, IntExpr a) {
    return a.solver().MakeProd(a, v);
  }
  public static IntExpr operator/(IntExpr a, long v) {
    return a.solver().MakeDiv(a, v);
  }
  public static IntExpr operator-(IntExpr a) {
    return a.solver().MakeOpposite(a);
  }
  public IntExpr Abs() {
    return this.solver().MakeAbs(this);
  }
  public IntExpr Square() {
    return this.solver().MakeSquare(this);
  }
  public static IntExprEquality operator ==(IntExpr a, IntExpr b) {
    return new IntExprEquality(a, b, true);
  }
  public static IntExprEquality operator !=(IntExpr a, IntExpr b) {
    return new IntExprEquality(a, b, false);
  }
  public static WrappedConstraint operator ==(IntExpr a, long v) {
    return new WrappedConstraint(a.solver().MakeEquality(a, v));
  }
  public static WrappedConstraint operator !=(IntExpr a, long v) {
    return new WrappedConstraint(a.solver().MakeNonEquality(a.Var(), v));
  }
  public static WrappedConstraint operator >=(IntExpr a, long v) {
    return new WrappedConstraint(a.solver().MakeGreaterOrEqual(a, v));
  }
  public static WrappedConstraint operator >(IntExpr a, long v) {
    return new WrappedConstraint(a.solver().MakeGreater(a, v));
  }
  public static WrappedConstraint operator <=(IntExpr a, long v) {
    return new WrappedConstraint(a.solver().MakeLessOrEqual(a, v));
  }
  public static WrappedConstraint operator <(IntExpr a, long v) {
    return new WrappedConstraint(a.solver().MakeLess(a, v));
  }
  public static WrappedConstraint operator >=(IntExpr a, IntExpr b) {
    return new WrappedConstraint(a.solver().MakeGreaterOrEqual(a.Var(), b.Var()));
  }
  public static WrappedConstraint operator >(IntExpr a, IntExpr b) {
    return new WrappedConstraint(a.solver().MakeGreater(a.Var(), b.Var()));
  }
  public static WrappedConstraint operator <=(IntExpr a, IntExpr b) {
    return new WrappedConstraint(a.solver().MakeLessOrEqual(a.Var(), b.Var()));
  }
  public static WrappedConstraint operator <(IntExpr a, IntExpr b) {
    return new WrappedConstraint(a.solver().MakeLess(a.Var(), b.Var()));
  }
%}

CS_TYPEMAP_STDVECTOR_OBJECT(operations_research::IntVar, IntVar)
CS_TYPEMAP_STDVECTOR_OBJECT(operations_research::SearchMonitor, SearchMonitor)
CS_TYPEMAP_STDVECTOR_OBJECT(operations_research::DecisionBuilder, DecisionBuilder)
CS_TYPEMAP_STDVECTOR_OBJECT(operations_research::IntervalVar, IntervalVar)
CS_TYPEMAP_STDVECTOR_OBJECT(operations_research::SequenceVar, SequenceVar)
CS_TYPEMAP_STDVECTOR_OBJECT(operations_research::LocalSearchOperator, LocalSearchOperator)
CS_TYPEMAP_STDVECTOR_OBJECT(operations_research::LocalSearchFilter, LocalSearchFilter)

namespace operations_research {
%extend IntervalVar {
  Constraint* EndsAfterEnd(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::ENDS_AFTER_END, other);
  }
  Constraint* EndsAfterStart(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::ENDS_AFTER_START, other);
  }
  Constraint* EndsAtEnd(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::ENDS_AT_END, other);
  }
  Constraint* EndsAtStart(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::ENDS_AT_START, other);
  }
  Constraint* StartsAfterEnd(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::STARTS_AFTER_END, other);
  }
  Constraint* StartsAfterStart(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STARTS_AFTER_START,
                                                   other);
  }
  Constraint* StartsAtEnd(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self, operations_research::Solver::STARTS_AT_END, other);
  }
  Constraint* StartsAtStart(IntervalVar* other) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STARTS_AT_START,
                                                   other);
  }
  Constraint* EndsAfter(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::ENDS_AFTER,
                                                   date);
  }
  Constraint* EndsAt(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::ENDS_AT,
                                                   date);
  }
  Constraint* EndsBefore(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::ENDS_BEFORE,
                                                   date);
  }
  Constraint* StartsAfter(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STARTS_AFTER,
                                                   date);
  }
  Constraint* StartsAt(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STARTS_AT,
                                                   date);
  }
  Constraint* StartsBefore(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::STARTS_BEFORE,
                                                   date);
  }
  Constraint* CrossesDate(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::CROSS_DATE,
                                                   date);
  }
  Constraint* AvoidsDate(int64 date) {
    return self->solver()->MakeIntervalVarRelation(self,
                                                   operations_research::Solver::AVOID_DATE,
                                                   date);
  }
  IntervalVar* RelaxedMax() {
    return self->solver()->MakeIntervalRelaxedMax(self);
  }
  IntervalVar* RelaxedMin() {
    return self->solver()->MakeIntervalRelaxedMin(self);
  }
}

%extend IntExpr {
  Constraint* MapTo(const std::vector<IntVar*>& vars) {
    return self->solver()->MakeMapDomain(self->Var(), vars);
  }
  IntExpr* IndexOf(const std::vector<int64>& vars) {
    return self->solver()->MakeElement(vars, self->Var());
  }
  IntExpr* IndexOf(const std::vector<IntVar*>& vars) {
    return self->solver()->MakeElement(vars, self->Var());
  }
  IntVar* IsEqual(int64 value) {
    return self->solver()->MakeIsEqualCstVar(self->Var(), value);
  }
  IntVar* IsDifferent(int64 value) {
    return self->solver()->MakeIsDifferentCstVar(self->Var(), value);
  }
  IntVar* IsGreater(int64 value) {
    return self->solver()->MakeIsGreaterCstVar(self->Var(), value);
  }
  IntVar* IsGreaterOrEqual(int64 value) {
    return self->solver()->MakeIsGreaterOrEqualCstVar(self->Var(), value);
  }
  IntVar* IsLess(int64 value) {
    return self->solver()->MakeIsLessCstVar(self->Var(), value);
  }
  IntVar* IsLessOrEqual(int64 value) {
    return self->solver()->MakeIsLessOrEqualCstVar(self->Var(), value);
  }
  IntVar* IsMember(const std::vector<int64>& values) {
    return self->solver()->MakeIsMemberVar(self->Var(), values);
  }
  IntVar* IsMember(const std::vector<int>& values) {
    return self->solver()->MakeIsMemberVar(self->Var(), values);
  }
  Constraint* Member(const std::vector<int64>& values) {
    return self->solver()->MakeMemberCt(self->Var(), values);
  }
  Constraint* Member(const std::vector<int>& values) {
    return self->solver()->MakeMemberCt(self->Var(), values);
  }
  IntVar* IsEqual(IntExpr* const other) {
    return self->solver()->MakeIsEqualVar(self->Var(), other->Var());
  }
  IntVar* IsDifferent(IntExpr* const other) {
    return self->solver()->MakeIsDifferentVar(self->Var(), other->Var());
  }
  IntVar* IsGreater(IntExpr* const other) {
    return self->solver()->MakeIsGreaterVar(self->Var(), other->Var());
  }
  IntVar* IsGreaterOrEqual(IntExpr* const other) {
    return self->solver()->MakeIsGreaterOrEqualVar(self->Var(), other->Var());
  }
  IntVar* IsLess(IntExpr* const other) {
    return self->solver()->MakeIsLessVar(self->Var(), other->Var());
  }
  IntVar* IsLessOrEqual(IntExpr* const other) {
    return self->solver()->MakeIsLessOrEqualVar(self->Var(), other->Var());
  }
  OptimizeVar* Minimize(long step) {
    return self->solver()->MakeMinimize(self->Var(), step);
  }
  OptimizeVar* Maximize(long step) {
    return self->solver()->MakeMaximize(self->Var(), step);
  }
}

%typemap(cscode) Solver %{
  public IntVar[] MakeIntVarArray(int count, long min, long max) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = MakeIntVar(min, max);
    }
    return array;
  }

  public IntVar[] MakeIntVarArray(int count, long min, long max, string name) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      string var_name = name + i;
      array[i] = MakeIntVar(min, max, var_name);
    }
    return array;
  }

  public IntVar[] MakeIntVarArray(int count, long[] values) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = MakeIntVar(values);
    }
    return array;
  }

  public IntVar[] MakeIntVarArray(int count, long[] values, string name) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      string var_name = name + i;
      array[i] = MakeIntVar(values, var_name);
    }
    return array;
  }

  public IntVar[] MakeIntVarArray(int count, int[] values) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = MakeIntVar(values);
    }
    return array;
  }

  public IntVar[] MakeIntVarArray(int count, int[] values, string name) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      string var_name = name + i;
      array[i] = MakeIntVar(values, var_name);
    }
    return array;
  }

  public IntVar[] MakeBoolVarArray(int count) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = MakeBoolVar();
    }
    return array;
  }

  public IntVar[] MakeBoolVarArray(int count, string name) {
    IntVar[] array = new IntVar[count];
    for (int i = 0; i < count; ++i) {
      string var_name = name + i;
      array[i] = MakeBoolVar(var_name);
    }
    return array;
  }

  public IntVar[,] MakeIntVarMatrix(int rows, int cols, long min, long max) {
    IntVar[,] array = new IntVar[rows, cols];
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        array[i,j] = MakeIntVar(min, max);
      }
    }
    return array;
  }

  public IntVar[,] MakeIntVarMatrix(int rows, int cols,
                                    long min, long max, string name) {
    IntVar[,] array = new IntVar[rows, cols];
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        string var_name = name + "["+ i + ", " + j +"]";
        array[i,j] = MakeIntVar(min, max, var_name);
      }
    }
    return array;
  }

  public IntVar[,] MakeIntVarMatrix(int rows, int cols, long[] values) {
    IntVar[,] array = new IntVar[rows, cols];
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        array[i,j] = MakeIntVar(values);
      }
    }
    return array;
  }

  public IntVar[,] MakeIntVarMatrix(int rows, int cols,
                                    long[] values, string name) {
    IntVar[,] array = new IntVar[rows, cols];
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        string var_name = name + "["+ i + ", " + j +"]";
        array[i,j] = MakeIntVar(values, var_name);
      }
    }
    return array;
  }

  public IntVar[,] MakeIntVarMatrix(int rows, int cols, int[] values) {
    IntVar[,] array = new IntVar[rows, cols];
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        array[i,j] = MakeIntVar(values);
      }
    }
    return array;
  }

  public IntVar[,] MakeIntVarMatrix(int rows, int cols,
                                    int[] values, string name) {
    IntVar[,] array = new IntVar[rows, cols];
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        string var_name = name + "["+ i + ", " + j +"]";
        array[i,j] = MakeIntVar(values, var_name);
      }
    }
    return array;
  }

  public IntVar[,] MakeBoolVarMatrix(int rows, int cols) {
    IntVar[,] array = new IntVar[rows, cols];
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        array[i,j] = MakeBoolVar();
      }
    }
    return array;
  }

  public IntVar[,] MakeBoolVarMatrix(int rows, int cols, string name) {
    IntVar[,] array = new IntVar[rows, cols];
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        string var_name = name + "["+ i + ", " + j +"]";
        array[i,j] = MakeBoolVar(var_name);
      }
    }
    return array;
  }

  public IntervalVar[] MakeFixedDurationIntervalVarArray(int count,
                                                         long start_min,
                                                         long start_max,
                                                         long duration,
                                                         bool optional) {
    IntervalVar[] array = new IntervalVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = MakeFixedDurationIntervalVar(start_min,
                                              start_max,
                                              duration,
                                              optional,
                                              "");
    }
    return array;
  }

  public IntervalVar[] MakeFixedDurationIntervalVarArray(int count,
                                                         long start_min,
                                                         long start_max,
                                                         long duration,
                                                         bool optional,
                                                         string name) {
    IntervalVar[] array = new IntervalVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = MakeFixedDurationIntervalVar(start_min,
                                              start_max,
                                              duration,
                                              optional,
                                              name + i);
    }
    return array;
  }

  public IntervalVar[] MakeFixedDurationIntervalVarArray(int count,
                                                         long[] start_min,
                                                         long[] start_max,
                                                         long[] duration,
                                                         bool optional,
                                                         string name) {
    IntervalVar[] array = new IntervalVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = MakeFixedDurationIntervalVar(start_min[i],
                                              start_max[i],
                                              duration[i],
                                              optional,
                                              name + i);
    }
    return array;
  }

  public IntervalVar[] MakeFixedDurationIntervalVarArray(int count,
                                                         int[] start_min,
                                                         int[] start_max,
                                                         int[] duration,
                                                         bool optional,
                                                         string name) {
    IntervalVar[] array = new IntervalVar[count];
    for (int i = 0; i < count; ++i) {
      array[i] = MakeFixedDurationIntervalVar(start_min[i],
                                              start_max[i],
                                              duration[i],
                                              optional,
                                              name + i);
    }
    return array;
  }

%}

%extend IntVarLocalSearchFilter {
  int Index(IntVar* const var) {
    int64 index = -1;
    self->FindIndex(var, &index);
    return index;
  }
}

// Protect from failure
#define PREPROTECT\
  FailureProtect protect;\
  Closure* const intercept = \
      NewCallback<>(&protect, &FailureProtect::JumpBack);\
  solver->set_fail_intercept(intercept);\
  if (setjmp(protect.exception_buffer) == 0) {

#define POSTPROTECT\
    solver->clear_fail_intercept();\
    delete intercept;\
  } else {\
    solver->clear_fail_intercept();\
  SWIG_CSharpSetPendingException(SWIG_CSharpApplicationException, "fail");\
    return $null;\
  }

%exception IntExpr::SetValue(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntExpr::SetMin(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntExpr::SetMax(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntExpr::SetRange(int64 mi, int64 ma) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception IntVar::RemoveValue(int64 v) {
  operations_research::Solver* const solver = arg1->solver();
  PREPROTECT
    $action
  POSTPROTECT
}
%exception Solver::AddConstraint(Constraint* const ct) {
  operations_research::Solver* const solver = arg1;
  PREPROTECT
    $action
  POSTPROTECT
}
%exception Solver::Fail() {
  operations_research::Solver* const solver = arg1;
  PREPROTECT
    $action
  POSTPROTECT
}
}  // namespace operations_research

namespace operations_research {
class LocalSearchPhaseParameters {
 public:
  LocalSearchPhaseParameters() {}
  ~LocalSearchPhaseParameters() {}
};
}  // namespace operations_research

#endif  // SWIGCSHARP

// Wrap cp includes
%include constraint_solver/constraint_solver.h
%include constraint_solver/constraint_solveri.h

// Define templates instantiation after wrapping.
namespace operations_research {
%template(RevInteger) Rev<int64>;
%template(RevBool) Rev<bool>;
typedef Assignment::AssignmentContainer AssignmentContainer;
%template(AssignmentIntContainer) AssignmentContainer<IntVar, IntVarElement>;
}
